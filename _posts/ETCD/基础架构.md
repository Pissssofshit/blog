## 拦截器

## 串行读和线性读

### 写流程
1. Leader 收到写请求，将此请求持久化到WAL日志，并广播到各个节点，若一般以上节点持久化成功，则该请求对应的日志条目被标识为已提交。
etcdserver模块异步从Raft模块获取已提交的日志条目，应用到**状态机(boltdb等)**(这个状态机是持久化存储的状态)

> etcd 一个节点单独的WAL日志和状态机?  

相当于WAL是先做一个预先同步，等半数以上节点同步完成之后，同步到状态机（相当于正式更新数据), 此时相当于集群达成共识了，更新成功了，Leader节点此时也可以响应请求更新成功了。

这种直接读状态机数据返回、无需通过 Raft 协议与集群进行交互的模式，在 etcd 里叫做串行 (Serializable) 读，它具有低延时、高吞吐量的特点，适合对数据一致性要求不高的场景。


## 线性读
线性读模块: 首先从Leader 获取集群最新的已提交的日志索引

即 Leader 节点持有的日志索引一定是最新的，所以其他节点在读之前，
要收到一个线性读请求时，集群会做以下工作:
* 从Leader 获取集群最新的已提交的日志索引
* Leader确认自身确实是Leader节点(每次读都会做这件事吗？)
Leader 收到 ReadIndex 请求时，为防止脑裂等异常场景，会向 Follower 节点发送心跳确认，一半以上节点确认 Leader 身份后才能将已提交的索引 (committed index) 返回给节点
* 节点等待，直到状态机已应用索引大于等于Leader的已提交索引，然后去通知读请求，可以去状态机中访问数据了

> 这个复杂效率会高吗？有没有其他方案？


### 事务的并发控制的思路
#### 加锁
#### MVCC
MVCC 是 Multiversion Concurrency Control 的英文缩写，也叫多版本并发控制.数据库领域，事务的并发控制是非常核心的一个话题

##### MVCC 解决的问题
* 读写之间阻塞的问题
通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。
数据多版本并发控制，可以实现读写并发。
2. 降低了死锁的概率
因为 InnoDB 的 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。
3. 解决一致性读的问题
一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。

##### etcd 怎么实现mvcc的
etcd 底层用的是 boltdb 做持久化的存储引擎，boltdb 是一个纯粹的 kv 存储。那现在问题来了，etcd 是怎么来存储用户的 key/value 呢？是否是直接把用户的 key 做 key，用户的 value 做 value，存入 boltdb 呢

etcd 内部生成了一个唯一 id 用作 boltdb 的 key，用户的 key/value 打包在一起作为 boltdb 的 value 存入 boltdb 的。

而这个所谓的 “内部唯一 id” 其实就是 revision 结构，一个主版本号（单调递增），一个次版本号。所以实际写入 boltdb 的 key/value 格式如下
```
key：revision
value：< 用户 key, 用户 value >
```
###### 怎么索引key
现在有一个问题，etcd底层存储的key 不是用户的key，所以需要由用户key关联到实际的key
索引结构:B树(全部在内存里)，key是用户key,value是keyindex 结构体
```
type keyIndex struct {
    key         []byte       // 用户 key
    modified    revision     // 最新的版本号；
    generations []generation // 一个key有可能是有多次创建，删除的，每一次的轮回都是一个 generation
}
```
这个结构体存储了这个key的所有轮回中进行的操作

## 资料
[云原生 etcd 系列｜深入剖析数据多版本 MVCC 机制](https://www.modb.pro/db/181297)
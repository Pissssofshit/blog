[TOC]

## 线程与协程
协程是用户态的线程，操作系统内核感知不到协程的存在，协程的管理依赖Go语言运行时自身提供的调度器。Go语言在线程的基础上抽象出协程的概念是为了xxx,从以下几个方面来分析线程和协程的不同g
goroutine是Go语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题，所谓的太重，主要表现在以下两个方面：

创建和切换太重：操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；

内存使用太重：一方面，为了尽量避免极端情况下操作系统线程栈的溢出，内核在创建操作系统线程时默认会为其分配一个较大的栈内存（虚拟地址空间，内核并不会一开始就分配这么多的物理内存），然而在绝大多数情况下，系统线程远远用不了这么多内存，这导致了浪费；另一方面，栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。

相对的，用户态的goroutine则轻量得多：

goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；
goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。

- [ ] 协程高效于线程的几个方面
### 调度方式
### 上下文切换的速度
* 协程切换不用经过操作系统用户态与内核态的切换。
* 并且Go语言中的协程切换只需要保留极少的状态和寄存器变量值（SP/BP/PC），而线程切换会保留额外的寄存器变量值（例如浮点寄存器）。
* 上下文切换的速度受到诸多因素的影响，这里列出一些值得参考的量化指标：线程切换的速度大约为1～2微秒，Go语言中协程切换的速度比它快数倍，为0.2微秒左右”

### 调度策略
线程: 大部分时间是抢占式的
协程: “而Go语言中的协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程。这意味着协程可以更好地在规定时间内完成自己的工作，而不会轻易被抢占。当一个协程运行了过长时间时，Go语言调度器才会强制抢占其执行（详见第15章）”

大体上是从特殊协程g0开始，找到接下来要运行的协程g,再从协程g切换到g0的调度过程

核心调度策略:
* 从runnext 中找下一个要运行的g
* 没有则从本地队列中找
* 本地队列为空则从全局队列找
* 全局队列没有则获取准备就绪的网络协程
* 没有则从其他P窃取
* 还是没找到则P进行休眠
调度时机:
* 主动调度
    * 取消G与M之间的绑定关系(为什么是G与M?)
    * 将G放入全局运行队列
    * 开始下一轮调度
* 被动调度
“被动调度指协程在休眠、channel通道堵塞、网络I/O堵塞、执行垃圾回收而暂停时，被动让渡自己执行权利的过程”
* 抢占调度
“为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。系统监控在一个独立的M上运行，不用绑定逻辑处理器P，系统监控每隔10ms会检测是否有准备就绪的网络协程，并放置到全局队列中。和抢占调度相关的是，系统监控服务会判断当前协程是否运行时间过长，或者处于系统调用阶段，如果是，则会抢占当前G的执行。其核心逻辑位于runtime.retake函数中”
- 在1.14之前，调度实际主要在执行函数调用阶段。但是如果执行过程中没有函数调用，协程将没有被抢占的机会
- [ ] 怎么确保抢占调度是安全的
“在抢占时，调度器通过向线程中发送sigPreempt信号，触发信号处理。在UNIX操作系统中，sigPreempt为_SIGURG信号，由于该信号不会被用户程序和调试器使用，因此Go语言使用它作为安全的抢占信号，关于信号具体的选择过程，可以参考Go源码中对_SIGURG信号的注释”

- [ ] 协程生命周期
- [ ] 协程的调度策略
- [ ] Go对I/O多路复用技术进行的封装
### 栈的大小
### 主协程与子协程
### GMP模型
#### 资料
- [ ] [Golang 调度器 GMP 原理与调度全分析
](https://learnku.com/articles/41728)
### 总结
### 协程的生命周期与状态转移
### 特殊协程g0与协程切换
### 线程本地存储与线程绑定
### 调度循环
### 调度策略
### 调度时机

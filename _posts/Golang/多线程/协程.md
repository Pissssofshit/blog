## 什么是线程
线程是进程中的执行体,拥有一个执行入口，分配在虚拟地址空间上的用户栈、内核栈，操作系统持有线程控制信息

## 什么是协程
协程就是线程在分配的用户栈上再自主创建的执行体 

## 协程上下文

## 为什么需要协程
如C、C++等并发实现多是基于线程模型的，就是应用程序负责创建线程（libpthread等库函数去实现），操作系统负责调度线程。这种模式就是有一些不足

复杂
1)写过C、C++的人肯定都知道，这里有多么的复杂，利用libpthread库中的API创建一个线程的时候，虽然要传入的参数很多，但是还可以接受。一旦涉及到线程的退出，那就要考虑新创建的线程是否要与主线程分离，还是需要主线程等待子线程终止并获取其终止状态？或者是否需要在新线程中设置取消点以保证被主线程取消的时候能顺利退出。


2)并发执行单元互相通信困难，容易出错：多个线程间的通信有很多机制，但用起来也是很复杂的；一旦用到共享内存，那就是各种锁机制，导致死锁，更是很轻松就做到的。

)我们使用线程的代价要比进程小很多，但是依然不能大量创建线程，除了每个线程占用的资源不小之外，操作系统调度切换线程的代价也很大。

2)很多服务端程序，由于不能大量创建线程，只能选择在少量线程里做网络多路复用的方案(事件流？)

Go采用了Goroutine来解决这些痛点。Goroutine占用资源非常小，每个Gorouine栈的大小默认是2k字节。goroutine调度的切换也不用在操作系统内核中完成，代价很低。所以一个Go程序可以创建成千上万个并发的goroutine，**而把这些goroutine按照一定算法放到cpu上执行的程序，我们就成为goroutine调度器（Scheduler）**。

我们看到在G-M中增加了一个P,这个P是何方神圣呢？ P是一个“逻辑Processor”,每个G要想真正运行起来，都需要被分配到一个P，即进入到P的本地运行队列中，先暂时忽略全局队列。对于G来说，P就是运行它的“CPU”,在G看来只有P。但从调度器的角度看，真正的“CPU”是M,只有将P和M绑定才能让P中的G真正的运行起来。这样的P与M的关系，类似Linux操作系统中用户线程和内核线程的对应关系(

协程的精髓在于控制流的主动让出与恢复，可以保存自己的执行现场。

## 协程与IO多路复用
操作系统持有进程的控制信息，里面有一个打开文件描述符表。


## 资料
https://juejin.cn/post/6920015953900077064
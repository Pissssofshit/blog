[TOC]

## 进程与线程与协程
线程是进程的执行体，线程共享进程资源
线程是操作系统最小的执行单元
协程就是线程在分配的用户栈上再自主创建的执行体 

## 线程上下文切换
当发生线程上下文切换时，需要从操作系统用户态转移到内核太，记录上一个线程的重要寄存器值、进程状态等信息。当切换到下一个要执行的线程时，需要重新加载重要xxxxx

- [ ] 线程上下文切换时，发生了什么？
1. 保存上下文(寄存器值、进程状态)

## 协程比线程的优势
*  线程使用比协程复杂
    * 需要额外管理线程的生命周期(主要是因为其直接面对操作系统?)
    一旦涉及到线程的退出，那就要考虑新创建的线程是否要与主线程分离，还是需要主线程等待子线程终止并获取其终止状态？或者是否需要在新线程中设置取消点以保证被主线程取消的时候能顺利退出
    * 并发执行单元互相通信困难，容易出错：
    多个线程间的通信有很多机制，但用起来也是很复杂的；一旦用到共享内存，那就是各种锁机制，导致死锁，更是很轻松就做到的。
* 线程比协程重
    * Goroutine占用资源非常小，每个Gorouine栈的大小默认是2k字节
    * 线程切换复杂
    需要由用户态进入内核态，再从内核态进入用户态，而协程调度则不需要
        * 协程切换不用经过操作系统用户态与内核态的切换。
        * 并且Go语言中的协程切换只需要保留极少的状态和寄存器变量值（SP/BP/PC），而线程切换会保留额外的寄存器变量值（例如浮点寄存器）。
    * 使用场景限制
    很多服务端程序，由于不能大量创建线程，只能选择在少量线程里做网络多路复用的方案

我们看到在G-M中增加了一个P,这个P是何方神圣呢？ P是一个“逻辑Processor”,每个G要想真正运行起来，都需要被分配到一个P，即进入到P的本地运行队列中，先暂时忽略全局队列。对于G来说，P就是运行它的“CPU”,在G看来只有P。但从调度器的角度看，真正的“CPU”是M,只有将P和M绑定才能让P中的G真正的运行起来。这样的P与M的关系，类似Linux操作系统中用户线程和内核线程的对应关系(

协程的精髓在于控制流的主动让出与恢复，可以保存自己的执行现场。

## 协程与IO多路复用
操作系统持有进程的控制信息，里面有一个打开文件描述符表。


## 资料
- [ ] [21.面试必问！Goroutine的调度原理](https://juejin.cn/post/6920015953900077064)

[你真的知道协程是怎么来的吗？](https://zhuanlan.zhihu.com/p/364587655)
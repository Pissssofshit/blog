[TOC]

## 概述
大体上是从特殊协程g0开始，找到接下来要运行的协程g,再从协程g切换到g0的调度过程

### 协程的生命周期与状态转移
- [ ] 协程的生命周期与状态转移

### 调度策略
~~线程: 大部分时间是抢占式的
协程: “而Go语言中的协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程。这意味着协程可以更好地在规定时间内完成自己的工作，而不会轻易被抢占。当一个协程运行了过长时间时，Go语言调度器才会强制抢占其执行（详见第15章）”~~

核心调度策略:
* 从runnext 中找下一个要运行的g
* 没有则从本地队列中找
* 本地队列为空则从全局队列找
* 全局队列没有则获取准备就绪的网络协程
* 没有则从其他P窃取
* 还是没找到则P进行休眠
## 调度时机
* 主动调度
    * 取消G与M之间的绑定关系(为什么是G与M?)
    * 将G放入全局运行队列
    * 开始下一轮调度
* 被动调度
被动调度指协程在休眠、channel通道堵塞、网络I/O堵塞、执行垃圾回收而暂停时，被动让渡自己执行权利的过程
* 抢占调度
为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。系统监控在一个独立的M上运行，不用绑定逻辑处理器P，系统监控每隔10ms会检测是否有准备就绪的网络协程，并放置到全局队列中。和抢占调度相关的是，系统监控服务会判断当前协程是否运行时间过长，或者处于系统调用阶段，如果是，则会抢占当前G的执行。其核心逻辑位于runtime.retake函数中
- 在1.14之前，调度实际主要在执行函数调用阶段。但是如果执行过程中没有函数调用，协程将没有被抢占的机会
- [ ] 怎么确保抢占调度是安全的
“在抢占时，调度器通过向线程中发送sigPreempt信号，触发信号处理。在UNIX操作系统中，sigPreempt为_SIGURG信号，由于该信号不会被用户程序和调试器使用，因此Go语言使用它作为安全的抢占信号，关于信号具体的选择过程，可以参考Go源码中对_SIGURG信号的注释”

- [ ] 协程的调度策略
- [ ] Go对I/O多路复用技术进行的封装
- [ ] [Golang 调度器 GMP 原理与调度全分析
](https://learnku.com/articles/41728)
### 总结

#### 优雅的停止、重启服务

如果你看过源码，也许会对以下这个写法感到奇怪

```
func (l *NSQLookupd) Main() error {
	exitCh := make(chan error)
	var once sync.Once
	exitFunc := func(err error) {
		once.Do(func() {
			if err != nil {
				l.logf(LOG_FATAL, "%s", err)
			}
			exitCh <- err
		})
	}

	l.waitGroup.Wrap(func() {
		exitFunc(protocol.TCPServer(l.tcpListener, l.tcpServer, l.logf)) // 初始化方法
	})
	httpServer := newHTTPServer(l)
	l.waitGroup.Wrap(func() {
		exitFunc(http_api.Serve(l.httpListener, httpServer, "HTTP", l.logf))
	})

	err := <-exitCh
	return err
}
```

这个 `TCPServer` 函数的主要目的是在一个永不退出的循环中处理传入的 TCP 连接。然而，`sync.WaitGroup` 的使用主要是为了确保在某些情况下，当服务器停止接受新的连接时，仍然能正确地处理和关闭已经建立的连接。

例如，在某些情况下，您可能需要手动停止服务器，例如进行优雅的关闭或重新加载配置。在这种情况下，您需要关闭 `listener`，这将导致 `Accept()` 方法返回一个错误，并使循环退出。然而，在这种情况下，您不希望立即结束程序，因为仍然可能有一些处理中的连接。

`sync.WaitGroup` 的作用是确保所有已经启动的 `handler.Handle()` goroutine 都能在 `TCPServer` 函数返回之前完成执行。当您关闭 `listener` 时，`for` 循环会退出，但在返回之前，`wg.Wait()` 会阻塞，直到所有处理中的连接都已完成。

这种设计可以确保在服务器停止接受新连接时，不会丢失任何已经建立的连接。这有助于确保在进行优雅关闭或重新加载配置等操作时，服务器能够正确地处理和关闭所有连接。
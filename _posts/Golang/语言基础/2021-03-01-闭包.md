---
title: 闭包
category: [Golang]
tags: [闭包, Golang]
layout: post
---

维基百科是这样介绍闭包的
```
在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持**头等函数**的编程语言中实现**词法绑定**的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）
```
[原文地址](https://zh.wikipedia.org/zh-cn/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))

这段话的信息量很大，首先它告诉我们闭包的结构:一个存储了函数入口与关联环境的结构体，它的性质：“它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行”。这句话具体到变量上会要求**闭包捕获的变量要在闭包函数和外层函数中表现一致**

在Golang中函数属于头等对象，可以被当作参数传递、也可以作为函数返回值、绑定到变量。Go语言称这样的参数、返回值和变量为"Function Value"。
Function Value本质上是一个指针，却不直接指向函数指令入口，而是指向runtime.funcval结构体。
```
type funcval struct {
    fn uintptr
}
```
fn指向函数指令的入口地址。捕获的自由变量通过funcval的地址加上偏移量获得。
因为捕获的自由变量需要由闭包对象各自持有，所以有捕获列表的Function Value要到执行阶段才会在堆上分配对应的funcval结构体以及捕获列表空间。
因为要满足**闭包捕获的变量要在闭包函数和外层函数中表现一致**,所以捕获的自由变量不是简单的值拷贝，而是要根据情况。
例如
```
func foo() func() {
  var x int = 1
  return func() {
    fmt.Printf("foo val = %d\n", x)
  }
}
```
这样的函数，捕获的变量x在声明初始化之后没有任何修改，所以捕获到堆上的就是变量值本身
再如
```
func foo() func() {
	var x int = 1
	tmp := func() {
		fmt.Printf("foo val = %d\n", x)
	}
	x = 2
	return tmp
}
```
传入闭包函数中的变量x在之后还有修改，为了达到**捕获变量在外层函数与闭包函数中的一致性**,
闭包函数捕获的就是变量值x的地址了

## 总结
1. Go语言里Function Value本质上是指向funcval结构体的指针；
2. Go语言里闭包只是拥有捕获列表的Function Value；
3. 捕获变量在外层函数与闭包函数中要保持一致。

## 闭包+defer的情况
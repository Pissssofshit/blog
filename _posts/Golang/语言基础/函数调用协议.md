---
layout: post
title: 函数调用协议
categories: [Golang]
tags: [Golang]
---

传参、(多)返回值、返回地址
## 函数栈帧
函数运行需要内存空间存放**局部变量**,**参数**,这段空间对应到虚拟地址空间的栈。运行时栈，上面是高地址，向下增长，栈底被称为**栈基**,栈顶被称为**栈指针**
### 布局
* 调用者栈基
* 函数的局部变量 <-- 从局部变量开始是函数栈指针
* 被调用函数返回值 <-- 调用其他函数的返回值
* 被调用函数参数 <-- 参数结束位置被称为函数栈基

> 参数和返回值的入栈顺序都是由右至左，因为这些都是被调用函数的返回值和参数，被调用函数通过栈指针加上偏移值这样相对寻址的方式来定位到自己的参数和返回值，这样由下至上正好先找到第一个参数，再找到第二个参数。

> 返回值通常是寄存器传递的，但Go语言支持多返回值，所以在栈上分配返回值空间更合适

## 栈增长
通常，Go的函数栈帧是一次性分配的（如有调用其他函数，会分配一个最大的能容纳返回值和参数的空间)，主要原因是避免栈访问越界。比如多个goroutine的情况，如歌各个g的函数栈帧都在逐步扩张，很容易发生栈访问越界

对于栈消耗较大的函数，go语言的编译器还会在函数头部插入检测代码，如果发现需要进行“栈增长”，就会另外分配一段足够大的栈空间，并把原来栈上的数据拷过来，原来的这段栈空间就被释放了

## 虚拟地址空间

## 寄存器
栈基：bp
栈顶：sp
指令寄存器：ip（是指向代码段中的指令）

指令寄存器中的值指向代码段中的指令


## 栈结构
Golang 由调用者维护参数和返回值:
返回地址
调用者栈基
局部变量
返回值(给调用函数的，由右至左)
参数(给调用函数的，由右至左)
返回地址


## 指令

call :
1. 将返回地址入栈
2. 跳转到被调用函数入口处(设置ip寄存器)

ret : 
1. pop
2. 设置ip到对应地址

## defer



## 参考资料
[1]https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html

## G

### 什么是goroutine
Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread，我们只会看到代码里满天飞的 goroutine。操作系统却相反，管你什么 goroutine，我才没空理会。我安心地执行线程就可以了，线程才是我调度的基本单位。

我们知道系统线程运行时，有寄存器存储着栈帧地址、指令地址等等，协程同样需要，所以... //TODO
```
当 goroutine 被调离 CPU 时，调度器负责把 CPU 寄存器的值保存在 g 对象的成员变量之中。

当 goroutine 被调度起来运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。
```

谈到 goroutine，绕不开的一个话题是：它和 thread 有什么区别？

参考资料【How Goroutines Work】告诉我们可以从三个角度区别：内存消耗、创建与销毀、切换。

内存占用

创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。

对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。

创建和销毀

Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。

切换

当 threads 切换时，需要保存各种寄存器，以便将来恢复：

16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.

而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。

一般而言，线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。

Goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。

因此，goroutine

//TODO go program => runtime 图

Go 程序的执行由两层组成：Go Program，Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutines 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。

## g中有什么

* 使用的栈
* 绑定的m
* 运行现场，寄存器的值

## 什么是m

### m中有什么

* 绑定的g
* 绑定的p

## 什么是p

再来看 P，取 processor 的首字母，为 M 的执行提供“上下文”，保存 M 执行 G 时的一些资源，例如本地可运行 G 队列，memeory cache 等。

### p中有什么

* 绑定的m
* 本地可运行的g队列

## gmp是怎么调度的

G 需要在 M 上才能运行，M 依赖 P 提供的资源，P 则持有待运行的 G

### 调度器

，保存调度器的状态信息、全局的可运行 G 队列等

重要的全局变量
```
// 保存所有的 g
allgs    []*g
// 保存所有的 m
allm        *m
// 保存所有的 p，_MaxGomaxprocs = 1024
allp        [ _MaxGomaxprocs + 1 ]*p
// p 的最大值，默认等于 ncpu
gomaxprocs  int32
// 程序启动时，会调用 osinit 函数获得此值
ncpu        int32
// 调度器结构体对象，记录了调度器的工作状态
sched       schedt
// 代表进程的主线程
m0           m
// m0 的 g0，即 m0.g0 = &g0
g0           g //主协程，栈分配在主线层栈上
```
g0是主协程对应的，栈是在主线程栈上分配的,g0持有m0的指针，m0也持有g0的指针，m0最初运行的协程也正是g0
//TODO 补充m和g关联的图
allgs 保存的是所有的g
allm保存的是所有的m

起初go语言中的调度模型中只有g和m，导致m从全局的G队列中拿取任务每次都要加锁。
于是引入了p。p有一个本地的g队列。
p与m关联，m直接从p中获取待执行的g,这样就不会频繁争抢任务了。全局的g队列则保存在了调度器中。
p

> 在程序初始化时，这些全局变量都会被初始化为零值

//TODO 可能要删掉这段
系统加载可执行文件大概都会经过这几个阶段：
> 从磁盘上读取可执行文件，加载到内存
创建进程和主线程
为主线程分配栈空间
把由用户在命令行输入的参数拷贝到主线程的栈
把主线程放入操作系统的运行队列等待被调度

## networkpoller

## 调度器调度的时机

```
func main() {
var x int
    threads := runtime.GOMAXPROCS(0)
    for i := 0 ; i < threads; i++ {
        go func() {
            for { x++ }

        }()
    }
    time.Sleep(time.Second)
    fmt.Println("x =", x)
}
```

https://golang.design/go-questions/sched/when/

## g0
主协程、栈分配在主线程栈



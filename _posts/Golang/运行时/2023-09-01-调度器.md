---
title: 调度
category: [Golang]
tags: [Golang]
layout: post
---
### GMP 调度模型
GMP是Golang的调度模型，该调度器使用称为 M:N 调度的技术，即在少数 OS 线程（M）上多路复用大量 Goroutines（N）。以下是 Goroutine 调度的基本原理：
Goroutine 调度的核心是 GMP 模型，其中：
- G 代表 Goroutine,goroutine是用户态的轻量级线程，Goroutine 在底层都对应一个 g 结构体，这个结构体包含了 Goroutine 的状态信息、堆栈信息、调度信息等。
状态信息：记录了 Goroutine 的当前状态，如运行中、可运行、等待中等。
堆栈信息：Goroutine 的执行栈，随着函数调用的深入会动态增长和缩小。
调度信息：包括指向分配给该 Goroutine 的 P（如果有的话）的指针，以及其他调度时需要的信息。。
三种 Goroutine 状态：
    - Runnable：等待在一个 M 上执行的 Goroutines。
    - Running：当前正在 M 上执行的 Goroutine。
    - Blocked：等待某些资源或事件的 Goroutines，例如等待 I/O、系统调用或锁。
- M 代表操作系统线程。
- P 代表处理器，它保存了本地 Goroutine 队列和其他调度相关信息。

### 调度时机
Go 调度器使用协同式调度（也称为非抢占式调度）。这意味着 Goroutines 必须定期与调度器合作，以便其他 Goroutines 能够运行。调度器的目标是尽可能地利用 CPU 资源，同时保持运行时的简单和性能。在 Go 的调度过程中，存在几种不同的调度时机，包括主动调度、被动调度以及抢占式调度。
> **协同式调度的含义**
在协同式调度（cooperative scheduling）模型中，任务（在Go中是Goroutines）在执行过程中，必须显式地指出放弃CPU控制的点。这与抢占式调度（preemptive scheduling）不同，在抢占式调度中，调度器可以在任何时候中断任务，将CPU控制权分配给另一个任务。因此，在协同式模型中，一个运行的Goroutine不会被强行中断，它必须主动“让出”CPU。

#### 主动调度
主动调度是指 Goroutine 明确放弃 CPU 执行权的情况，这通常发生在以下场景：
1. 阻塞操作：当 Goroutine 执行系统调用或者其他阻塞操作（如发送/接收通道操作等待）时，它会被挂起，运行时调度器会选择另一个 Goroutine 继续执行。
2. Goroutine 结束：当 Goroutine 正常结束其执行流程时，它会主动让出 CPU，调度器随后将从本地或全局运行队列中选取另一个 Goroutine 执行。
3. Goroutine 显式调用了 runtime.Gosched()。

#### 被动调度
被动调度是指 Goroutine 在没有明确放弃执行权的情况下发生调度，这通常涉及以下场景：
1. 系统监控（sysmon）线程的干预：如上文提到，sysmon 线程负责监控整个系统的健康状况，包括触发垃圾收集或调整线程数量等。这些操作可能间接影响到 Goroutine 的调度。
2. 网络轮询器（netpoller）事件：对于使用非阻塞 I/O 的 Goroutines，当相关的 I/O 事件就绪时，它们可以被网络轮询器唤醒并参与调度，这种情况下 Goroutine 被动地重新进入运行队列。
> Go语言的调度器是其并发模型的核心，提供了Goroutines的高效调度。系统监控（sysmon）线程在Go调度器中扮演着特殊而重要的角色，尽管它并不直接参与Goroutines的调度，但它确保了系统的健康运行和性能。以下是sysmon线程的主要活动和任务：
强制GC（垃圾收集）的启动
sysmon线程会定期检查内存的增长情况，并在必要时触发垃圾收集（GC）过程。这有助于在没有足够内存分配压力的情况下，保持内存使用的平衡。
检测和唤醒睡眠中的Goroutines
Go调度器尝试保持最小的Goroutines在运行状态，以减少上下文切换的开销。sysmon负责监控长时间没有被调度执行的Goroutines，并在必要时将它们标记为可运行状态（runnable），以便调度器可以重新调度它们。
管理定时器
sysmon负责检查和处理到期的定时器事件。它会周期性地检查是否有定时器需要触发，并将对应的Goroutines置于可运行状态，以便它们可以处理定时器事件。
实施抢占式调度
从Go 1.14开始，Go引入了基于函数调用的抢占，这允许调度器在Goroutines执行长时间操作时，强制将其抢占。sysmon线程在这个过程中发挥作用，通过周期性检查运行时间过长的Goroutines，并触发它们的抢占，以保证调度器的公平性和响应性。
网络轮询器的监控
sysmon线程还负责监视网络轮询器（network poller），确保异步IO操作（如网络读写操作）能够及时唤醒相应的Goroutines。
调整线程数量
sysmon可以根据当前的工作负载，调整系统中工作线程（worker threads）的数量，以优化资源使用和调度效率。

#### 抢占式调度
从 Go 1.14 开始，Go 引入了基于抢占的调度方式，以解决长时间运行的 Goroutine 可能导致的调度延迟问题。抢占式调度允许运行时系统在以下情况下强制中断 Goroutine 的执行：
1. 定时抢占：运行时会定期检查正在执行的 Goroutine，如果一个 Goroutine 运行时间过长（通常是几十毫秒），运行时会尝试抢占它，让出 CPU 给其他 Goroutine。
2. 同步调用抢占：当 Goroutine 执行同步调用，如锁操作，且存在等待锁的其他 Goroutine 时，执行同步调用的 Goroutine 可能被抢占，以提高锁的公平性和减少等待时间。
抢占式调度的引入大大提高了 Go 程序的响应性和公平性，特别是在面对长时间运行计算或复杂循环操作的 Goroutines 时。这些调度时机共同工作，确保了 Go 运行时的高效并发执行，允许开发者构建出既高性能又具有良好响应性的应用。

**抢占式调度的实现：**
1. 函数调用计数：Go 运行时会周期性地检查每个 Goroutine 是否已经运行了足够长的时间并需要被抢占。这是通过计算函数调用的数量来实现的。当函数调用达到一定的阈值时，运行时会插入一个抢占检查。
2. 抢占检查：在抢占检查点，Go 运行时会检查是否有一个抢占请求。如果存在，当前 Goroutine 会被挂起，调度器将选择另一个 Goroutine 运行。
3. 异步抢占：在 Go 1.14 中引入的另一个机制是使用操作系统的异步信号来抢占 Goroutine。当调度器决定抢占一个 Goroutine 时，它会向对应的 OS 线程发送一个异步信号。当线程收到这个信号时，它会导致当前运行的 Goroutine 保存其状态并让出 CPU，从而允许其他 Goroutines 运行。
确保抢占式调度的安全性：
1. 安全点：Go 运行时确保 Goroutines 只在所谓的“安全点”被抢占。安全点是指运行时可以准确知道 Goroutine 的所有寄存器和堆栈的状态的点。这确保了当 Goroutine 被恢复时，它可以从中断点安全地继续执行。
2. 栈扫描：由于 Go 使用的是移动的垃圾回收器，这意味着对象可以在堆上移动，所以需要知道所有 Goroutine 的精确状态来更新它们的堆栈引用。通过只在安全点抢占 Goroutines，Go 确保它可以准确地执行这些更新。
3. 最小的抢占窗口：通过将抢占限制为函数调用和明确的检查点，Go 减少了潜在的中断窗口，从而减少了因抢占引入的不确定性和性能开销。
工作窃取
为了平衡每个 P 上的 Goroutine 负载，Go 调度器实现了工作窃取算法。如果一个 P 的本地队列为空，它可以尝试从另一个 P 的队列“窃取” Goroutines。

## 资料
[] [21.面试必问！Goroutine的调度原理](https://juejin.cn/post/6920015953900077064)
[] [Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
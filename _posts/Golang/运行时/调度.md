[TOC]


## G

### 什么是goroutine
Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread，我们只会看到代码里满天飞的 goroutine。操作系统却相反，管你什么 goroutine，我才没空理会。我安心地执行线程就可以了，线程才是我调度的基本单位。

> 用户态的线程

我们知道系统线程运行时，有寄存器存储着栈帧地址、指令地址等等，协程同样需要，所以... //TODO
```
当 goroutine 被调离 CPU 时，调度器负责把 CPU 寄存器的值保存在 g 对象的成员变量之中。

当 goroutine 被调度起来运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。
```

谈到 goroutine，绕不开的一个话题是：它和 thread 有什么区别？

参考资料【How Goroutines Work】告诉我们可以从三个角度区别：内存消耗、创建与销毀、切换。

内存占用

创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。

对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。

创建和销毀

Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。

切换

当 threads 切换时，需要保存各种寄存器，以便将来恢复：

16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.

而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。

一般而言，线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。

Goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。

因此，goroutine

//TODO go program => runtime 图

Go 程序的执行由两层组成：Go Program，Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutines 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。

## g中有什么

* 使用的栈
* 绑定的m
* 运行现场，寄存器的值

## 什么是m

### m中有什么

* 绑定的g
* 绑定的p

## 什么是p

再来看 P，取 processor 的首字母，为 M 的执行提供“上下文”，保存 M 执行 G 时的一些资源，例如本地可运行 G 队列，memeory cache 等。

### p中有什么

* 绑定的m
* 本地可运行的g队列

## gmp是怎么调度的

G 需要在 M 上才能运行，M 依赖 P 提供的资源，P 则持有待运行的 G

### 调度器

，保存调度器的状态信息、全局的可运行 G 队列等

重要的全局变量
```
// 保存所有的 g
allgs    []*g
// 保存所有的 m
allm        *m
// 保存所有的 p，_MaxGomaxprocs = 1024
allp        [ _MaxGomaxprocs + 1 ]*p
// p 的最大值，默认等于 ncpu
gomaxprocs  int32
// 程序启动时，会调用 osinit 函数获得此值
ncpu        int32
// 调度器结构体对象，记录了调度器的工作状态
sched       schedt
// 代表进程的主线程
m0           m
// m0 的 g0，即 m0.g0 = &g0
g0           g //主协程，栈分配在主线层栈上
```
g0是主协程对应的，栈是在主线程栈上分配的,g0持有m0的指针，m0也持有g0的指针，m0最初运行的协程也正是g0
//TODO 补充m和g关联的图
allgs 保存的是所有的g
allm保存的是所有的m

起初go语言中的调度模型中只有g和m，导致m从全局的G队列中拿取任务每次都要加锁。
于是引入了p。p有一个本地的g队列。
p与m关联，m直接从p中获取待执行的g,这样就不会频繁争抢任务了。全局的g队列则保存在了调度器中。
p

> 在程序初始化时，这些全局变量都会被初始化为零值

//TODO 可能要删掉这段
系统加载可执行文件大概都会经过这几个阶段：
> 从磁盘上读取可执行文件，加载到内存
创建进程和主线程
为主线程分配栈空间
把由用户在命令行输入的参数拷贝到主线程的栈
把主线程放入操作系统的运行队列等待被调度

## networkpoller

## 调度器调度的时机

```
func main() {
var x int
    threads := runtime.GOMAXPROCS(0)
    for i := 0 ; i < threads; i++ {
        go func() {
            for { x++ }

        }()
    }
    time.Sleep(time.Second)
    fmt.Println("x =", x)
}
```

https://golang.design/go-questions/sched/when/

## g0
主协程、栈分配在主线程栈



## 概述
大体上是从特殊协程g0开始，找到接下来要运行的协程g,再从协程g切换到g0的调度过程

### 协程的生命周期与状态转移
- [ ] 协程的生命周期与状态转移

### GMP 模型
G - 协程
M - 线程 ( hand off 机制)
P - CPU
## GMP模型
TODO 更多
从依附关系上来说，M依附于内核线程，P依附于M，G依附于P，M和P共同为G提供有效的运行环境
M，即 machine，相当于内核线程在 Go 进程中的映射，它与内核线程一一对应，代表真正执行计算的资源。在 M 的生命周期内，它只会与一个内核线程关联。

P，即 processor，代表 Go 代码片段执行所需的上下文环境。M 和 P 的结合能够为 G 提供有效的运行环境，它们之间的结合关系不是固定的。P 的最大数量决定了 Go 程序的并发规模，由 runtime.GOMAXPROCS 变量决定。

G，即 goroutine，是一种轻量级的用户线程，是对代码片段的封装，拥有执行时的栈、状态和代码片段等信息。



#### 设计策略
复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
1）work stealing 机制
​ 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
2）hand off 机制

 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。

抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。

全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

~~线程: 大部分时间是抢占式的
协程: “而Go语言中的协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程。这意味着协程可以更好地在规定时间内完成自己的工作，而不会轻易被抢占。当一个协程运行了过长时间时，Go语言调度器才会强制抢占其执行（详见第15章）”~~

核心调度策略:
* 从runnext 中找下一个要运行的g
* 没有则从本地队列中找
* 本地队列为空则从全局队列找
* 全局队列没有则获取准备就绪的网络协程
* 没有则从其他P窃取
* 还是没找到则P进行休眠
## 调度时机
* 主动调度
    * 取消G与M之间的绑定关系(为什么是G与M?)
    * 将G放入全局运行队列
    * 开始下一轮调度
* 被动调度
被动调度指协程在休眠、channel通道堵塞、网络I/O堵塞、执行垃圾回收而暂停时，被动让渡自己执行权利的过程
* 抢占调度
为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。系统监控在一个独立的M上运行，不用绑定逻辑处理器P，系统监控每隔10ms会检测是否有准备就绪的网络协程，并放置到全局队列中。和抢占调度相关的是，系统监控服务会判断当前协程是否运行时间过长，或者处于系统调用阶段，如果是，则会抢占当前G的执行。其核心逻辑位于runtime.retake函数中
- 在1.14之前，调度实际主要在执行函数调用阶段。但是如果执行过程中没有函数调用，协程将没有被抢占的机会
- [ ] 怎么确保抢占调度是安全的
“在抢占时，调度器通过向线程中发送sigPreempt信号，触发信号处理。在UNIX操作系统中，sigPreempt为_SIGURG信号，由于该信号不会被用户程序和调试器使用，因此Go语言使用它作为安全的抢占信号，关于信号具体的选择过程，可以参考Go源码中对_SIGURG信号的注释”
### 调度策略

## 资料
- [ ] 协程的调度策略
- [ ] Go对I/O多路复用技术进行的封装
- [ ] [Golang 调度器 GMP 原理与调度全分析
](https://learnku.com/articles/41728)
### 总结

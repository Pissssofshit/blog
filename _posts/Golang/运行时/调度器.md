[TOC]

## 线程、协程、调度器
一个线程可以分为 “内核态”线程和“用户态”线程
> 为什么？
一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”(Linux 的 PCB 进程控制块)。
这样，我们再去细化去分类一下，内核线程依然叫 “线程 (thread)”，用户线程叫 “协程 (co-routine)”.

在协程:线程(内核线程) N:1的情况下，需要一个调度器来调度协程
线程则是由操作系统调度

## GPM
### 概述
G - 用户态协程
P - 代表CPU资源
M - 代表系统线程

从依附关系上来说，M依附于内核线程，P依附于M，G依附于P，M和P共同为G提供有效的运行环境
M，即 machine，相当于内核线程在 Go 进程中的映射，它与内核线程一一对应，代表真正执行计算的资源。在 M 的生命周期内，它只会与一个内核线程关联。

P，即 processor，代表 Go 代码片段执行所需的上下文环境。M 和 P 的结合能够为 G 提供有效的运行环境，它们之间的结合关系不是固定的。P 的最大数量决定了 Go 程序的并发规模，由 runtime.GOMAXPROCS 变量决定。

G，即 goroutine，是一种轻量级的用户线程，是对代码片段的封装，拥有执行时的栈、状态和代码片段等信息。


### 设计策略(待补充)
复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
1）work stealing 机制
​ 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
2）hand off 机制

 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。

抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。

全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

### G
#### Goroutine 与 thread 的区别
* 内存消耗
* 创建与销毁
* 切换
##### 内存消耗
创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。

##### 创建和销毁
Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。

##### 切换
当 threads 切换时，需要保存各种寄存器，以便将来恢复：
而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。(有待考证)
线程切换的速度大约为1～2微秒，Go语言中协程切换的速度比它快数倍，为0.2微秒左右

#### g中有什么(待补充)

* 使用的栈
* 绑定的m
* 运行现场，寄存器的值

### M(好像没啥东西)

### P
再来看 P，取 processor 的首字母，为 M 的执行提供“上下文”，保存 M 执行 G 时的一些资源，例如本地可运行 G 队列，memeory cache 等。

#### p中有什么(待补充)
* 绑定的m
* 本地可运行的g队列

### 调度器
#### 何时发生调度(待补充)
* **同步协作式调度**
1. 主动用户让权：通过 runtime.Gosched 调用主动让出执行机会；
2. 主动调度弃权：当发生执行栈分段时，检查自身的抢占标记，决定是否继续执行；
* **异步抢占式调度**
1. 被动监控抢占：当 G 阻塞在 M 上时（系统调用、channel 等），系统监控会将 P 从 M 上抢夺并分配给其他的 M 来执行其他的 G，而位于被抢夺 P 的 M 本地调度队列中 的 G 则可能会被偷取到其他 M 中。
2. 被动 GC 抢占：当需要进行垃圾回收时，为了保证不具备主动抢占处理的函数执行时间过长，导致 导致垃圾回收迟迟不得执行而导致的高延迟，而强制停止 G 并转为执行垃圾回收。

> 信号处理的基本做法，其核心是注册 sighandler 函数，并在信号到达后， 由操作系统中断转入内核空间，而后将所中断线程的执行上下文参数（例如寄存器 rip, rep 等） 传递给处理函数。如果在 sighandler 中修改了这个上下文参数，操作系统则会根据修改后的 上下文信息恢复执行，这也就为抢占提供了机会。

#### 调度策略(待补充)
大体上是从特殊协程g0开始，找到接下来要运行的协程g,再从协程g切换到g0的调度过程

核心调度策略:
* 从runnext 中找下一个要运行的g
* 没有则从本地队列中找
* 本地队列为空则从全局队列找
* 全局队列没有则获取准备就绪的网络协程
* 没有则从其他P窃取
* 还是没找到则P进行休眠



#### 调度器的生命周期(待补充)
#### 调度器有什么(待补充)

##### 特殊的g0和m0(待补充)
g0是调度协程
M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。
G0 是每次启动一个 M 都会第一个创建的 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。

### 通过trace追踪GMP信息
### 总结
## 资料
[Golang 调度器 GMP 原理与调度全分析
](https://learnku.com/articles/41728)
[6.8 协作与抢占](https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/)


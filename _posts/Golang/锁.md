[TOC]

## 互斥锁的实现机制
### 临界区
临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用
## 实现
## 数据结构
## 模式
### 正常模式
### 饥饿模式
## 可重入锁
在工程中使用互斥的根本原因是：为了保护不变量，也可以用于保护内、外部的不变量。

基于此，Go 在互斥锁设计上会遵守这几个原则。如下：

在调用 mutex.Lock 方法时，要保证这些变量的不变性保持，不会在后续的过程中被破坏。
在调用 mu.Unlock 方法时，要保证：
程序不再需要依赖那些不变量。
如果程序在互斥锁加锁期间破坏了它们，则需要确保已经恢复了它们。
不支持的原因
讲了 Go 自己的设计原则后，那为什么不支持可重入呢？

其实 Russ Cox 于 2010 年在《Experimenting with GO》就给出了答复，认为递归（又称：重入）互斥是个坏主意，这个设计并不好。

我们可以结合官方的例子来理解。
```
func F() {
        mu.Lock()
        ... do some stuff ...
        G()
        ... do some more stuff ...
        mu.Unlock()
}

func G() {
        mu.Lock()
        ... do some stuff ...
        mu.Unlock()
}
```
---
title: 分布式锁
category: [Redis]
tags: [Redis]
layout: post
---
## 基本性质
分布式锁的实现要满足以下性质
* 互斥性: 任意时刻，只有一个客户端能持有锁。
锁超时释放：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。
* 可重入性:一个线程如果获取了锁之后,可以再次对其请求加锁。
* 高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。
* 安全性：锁只能被持有的客户端删除，不能被其他客户端删除
> 分布式锁为什么一般要实现可重入性？
分布式锁的可重入性意味着在同一个线程（或处理单元）内，一个已经获得锁的实体可以多次重新获取并释放该锁，而不会被锁住。实现分布式锁的可重入性有以下几个原因：
1. 避免死锁：可重入性的主要好处之一是防止死锁。考虑一个场景，其中一个线程已经获取了一个锁，然后在其持有的锁的保护下再次尝试获取同一个锁。如果分布式锁不是可重入的，该线程将会被阻塞，因为它在等待一个已经被其自己持有的锁，从而导致死锁。
2. 简化编程模型：可重入性简化了编程模型，使得开发者不必担心已经在当前线程中持有的锁。它允许方法递归地调用自己或调用其他同步方法，而不必担心是否已经持有锁。
3. 提高灵活性：在复杂的操作中，一个操作可能需要多次获取锁。如果锁是可重入的，这样的操作就可以在不释放锁的情况下多次获取它，这为复杂的事务提供了更大的灵活性。
4. 减少错误：在复杂的应用逻辑中，开发者可能不总是清楚地知道锁何时被获取或释放。可重入性减少了因意外再次获取已持有的锁而导致的错误。
5. 性能优化：再次获取已持有的锁通常比首次获取锁要快，因为它可以避免与外部系统（例如，分布式锁服务）的额外通信。
然而，实现分布式锁的可重入性也带来了一些挑战，如跟踪重入次数和确定何时真正释放锁。

## 实现
### 上锁
Redis执行命令是单线程的，因此在Redis中设置键值就可以作为获取分布式锁的命令
SET的扩展命令（SET EX PX NX）（设置值的同时原子性的设置过期时间），一个命令就可以原子性的完成设置锁、不抢占锁、设置过期时间
SET key value[EX seconds][PX milliseconds][NX|XX]
- NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。
- EX seconds :设定key的过期时间，时间单位是秒。
- PX milliseconds: 设定key的过期时间，单位为毫秒
- XX: 仅当key存在时设置值
### 解锁
通过lua脚本保证锁的所有者验证和解锁操作的原子性
```
if redis.call('get',KEYS[1]) == ARGV[1] then 
   return redis.call('del',KEYS[1]) 
else
   return 0
end;
```
### 锁续期
自动为持有的锁续期，以确保长时间运行的任务不会因为锁超时而失去锁。
以下是Golang的简单实现

```
type RedisLock struct {
    client   *redis.Client
    key      string
    value    string
    ttl      time.Duration
    stopChan chan bool
}

func NewRedisLock(client *redis.Client, key string, value string, ttl time.Duration) *RedisLock {
    return &RedisLock{
        client:   client,
        key:      key,
        value:    value,
        ttl:      ttl,
        stopChan: make(chan bool),
    }
}

func (r *RedisLock) Lock() bool {
    // 使用SET命令来尝试获取锁
    success, err := r.client.SetNX(r.key, r.value, r.ttl).Result()
    if err != nil || !success {
        return false
    }

    // 启动背景任务来定期续期锁
    go r.renewLock()

    return true
}

func (r *RedisLock) Unlock() {
    // 发送停止信号到续期背景任务
    r.stopChan <- true

    // 释放锁
    r.client.Del(r.key)
}

func (r *RedisLock) renewLock() {
    ticker := time.NewTicker(r.ttl / 2)
    for {
        select {
        case <-ticker.C:
            r.client.Expire(r.key, r.ttl)
        case <-r.stopChan:
            ticker.Stop()
            return
        }
    }
}
```
以上实现基于单个Redis节点来获取和释放锁。如果这个Redis节点出现故障，整个锁服务将不可用，这就产生了单点故障的风险。Redlock通过使用多个Redis实例来避免单点故障，提高了系统的可用性和容错性。
## RedLock
Redlock 是一个分布式锁的算法，由 Redis 的作者 Salvatore Sanfilippo 提出。在分布式系统中，有时多个节点需要对共享资源进行互斥访问，而传统的单节点锁在这种环境下不能工作。Redlock 提供了一种在没有中央协调者的情况下在多个 Redis 节点之间实现分布式锁的方法。
Redlock 解决的主要问题是：在一个不完全可靠的网络中，如何确保在任何给定的时间只有一个客户端可以持有锁？
以下是 Redlock 试图解决的一些具体挑战：
1. 单点故障：如果你只使用单个 Redis 节点来实现锁，那么当该节点不可用时，整个锁机制会失败。通过使用多个 Redis 实例，Redlock 试图消除这种单点故障。
2. 锁超时：在分布式环境中，一个客户端可能无法释放它持有的锁（例如，由于崩溃或网络分区）。Redlock 通过为锁设置一个时间限制来处理这个问题。如果持有锁的客户端在这个时间内没有释放或续期锁，锁将自动过期。
3. 强制锁释放：在某些情况下，一个客户端可能需要强制释放另一个客户端持有的锁。Redlock 通过使用一个随机的 128 位值作为锁的值来处理这个问题。只有知道这个值的客户端才能释放锁。
4. 确保锁的安全性：为了确保只有一个客户端可以持有锁，Redlock 要求你使用至少五个 Redis 节点。一个客户端只有在获得大多数节点的认可后才能获取锁。这确保了即使在少数节点出现网络分区或延迟的情况下，锁的安全性仍然得到保障。
Redlock 解决单点故障的核心思想是：使用多个独立的 Redis 实例或集群来存放锁信息，从而确保在某些节点失效时，整个锁机制仍然可以正常工作。下面是 Redlock 如何具体解决单点故障问题的：
1. 多个 Redis 节点：Redlock 算法建议使用至少五个独立的 Redis 节点。这些节点之间不共享任何数据（即，它们不是主从复制或集群模式）。
2. 锁的获取：
   - 当客户端尝试获取锁时，它会向所有五个 Redis 节点发送锁请求。
   - 锁请求包含三个参数：资源标识符、一个随机生成的值（用作锁的值）和锁的过期时间。
   - 为了避免时间同步问题，每个 Redis 节点使用其自己的系统时钟来确定锁的过期时间。
   - 客户端会尝试在尽可能短的时间内（例如，几毫秒内）获取所有节点上的锁。
3. 成功的条件：
   - 只有在客户端成功地从大多数（至少三个）Redis 节点上获取了锁，它才认为它已经成功获取了锁。
   - 这确保了即使在两个 Redis 节点失效的情况下，客户端仍然可以获取和释放锁。
4. 锁的释放：
   - 当客户端想释放一个锁时，它会向所有五个 Redis 节点发送释放锁的请求。（也需要从大部分的节点上成功释放才认为成功释放）
   - 由于只有持有锁的客户端知道锁的随机值，所以只有该客户端可以释放锁。
通过这种方式，Redlock 确保了即使某些 Redis 节点不可用，分布式锁仍然可以正常工作，从而解决了单点故障问题。然而，这也意味着在获取和释放锁时需要多次与多个 Redis 节点进行通信，这可能会增加延迟和复杂性。
## Redis集群
对于具有哨兵或集群结构的 Redis 设置来说，其本身就提供了高可用性和故障转移能力，因此在很大程度上可以避免上面提到的单点故障。
与Redis集群相较，Redlock 在以下情况下仍是有价值的：
1. 跨数据中心的分布式锁：如果您的应用部署在多个地理位置分散的数据中心，且需要在所有这些数据中心之间实现一个全局的分布式锁，Redlock 可能是一个合适的选择。
2. 独立的 Redis 节点：如果您已经有多个独立运行的 Redis 实例（这些实例之间不共享任何资源或拓扑结构），Redlock 可以帮助您在这些节点上实现分布式锁。
3. 严格的锁定语义：Redlock 为锁提供了一些严格的语义，例如锁的超时和重试机制。这些语义可能超出了单个 Redis 实例或集群所能提供的。

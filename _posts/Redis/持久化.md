## AOF（Append Only File）日志

### 是什么

每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里(先写入内存，后记录命令到日志)

### 为什么先写内存后写日志

#### 好处

* 避免额外检查开销(命令已经经过Redis语法检查了)
* 不会阻塞当前写操作（但由于写入AOF也是在主线程中执行的，所以当Redis把日志文件写入到磁盘的时候，还是会阻塞后续操作无法执行)

#### 坏处

* 数据可能丢失：写入内存后发生宕机

#### 写回策略

1. Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；
2. 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；
3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。

内核缓冲区数据写入硬盘的时机可以有三种:总是，每秒，不（有内核决定合适写入硬盘)

#### AOF重写机制

AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。

所以，Redis 为了避免 AOF 文件越写越大，提供了  **AOF 重写机制** ，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

##### 怎么做

AOF 重写机制是在重写时，**读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。**

##### 重写过程

###### 由谁来重写

Redis 的 **重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的** ，这么做可以达到两个好处：

* 不会阻塞主进程
* 子进程带有主进程的数据副本，当父子进程任意一方修改了该共享内存，就会发生写时复制。如果是线程，多线程之间会共享内存，那么在修改共享内存数据时，需要通过加锁来保证数据安全，这样会降低性能。

###### AOF重写过程中，发生的数据变更怎么办

为了解决这种数据不一致问题，Redis 设置了一个  **AOF 重写缓冲区** ，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。

在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会 **同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」** 。

主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：

* 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；
* 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。

信号函数执行完后，主进程就可以继续像往常一样处理命令了。

## RDB 快照

RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。

### 谁来做

执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**

## 混合持久化

RDB 优点是数据恢复速度快，但是快照的频率不好把握。**频率太低，丢失的数据就会比较多，频率太高，就会影响性能。**

> 所以最好就是频率低，然后再更新这段时间内的数据变更

AOF 优点是丢失数据少，但是数据恢复不快。

为了集成了两者的优点， Redis 4.0 提出了 **混合使用 AOF 日志和内存快照** ，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。

在开启了混合持久化之后，AOF文件格式变为：前面部分是RDB文件+在重写过程中被记录在重写缓冲区中的命令（即原始的AOF文件格式) ,这样前半部分是RDB加载快，后半部分数据量小，也快

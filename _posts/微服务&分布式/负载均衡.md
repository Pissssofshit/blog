[TOC]

## 什么是负载均衡
一般来说，互联网应用在其发展初期，往往采用单实例部署，用户通过网络请求某个固定IP地址的服务实例，这在用户量不大时是可行的。随着用户量的提升，单机单实例的服务已经无法应对用户的请求，并且单机单实例存在单点错误问题，一旦该实例出现问题，就会导致系统不可用，影响应用可用性。

所以，如下图所示，服务会进行多实例部署，由负载均衡集群将用户请求分发给不同的服务实例，既提高了系统整体的吞吐量，也避免了因为单一服务实例宕机导致整个系统不可用的情况。

## 负载均衡实现的方式
软件负载均衡，顾名思义，就是使用独立的负载均衡软件来实现请求的分发。它配置较为简单并且使用成本不高，能够满足大多数的负载均衡要求。但是软件所部署服务器的性能会成为整个系统吞吐量的瓶颈，并且还会产生单点错误。

硬件负载均衡则是依赖于特殊的负载均衡硬件设备来分发请求到不同的服务实例。相比于软件负载均衡，它能够提供更高的性能、更加多样化的负载均衡策略和更加细粒度的流量管理，更好地满足整体系统所需的负载均衡要求，但是成本极高，需要专门的硬件设备，整体投入费用较高。

在软件负载均衡类别中，大家最为熟悉、最为常见的负载均衡方案还是反向代理负载均衡，几乎所有的主流Web服务器都支持基于反向代理的负载均衡。Web服务器实现反向代理负载均衡的核心机制就是转发HTTP请求到不同的服务实例。

上述方案都是服务端负载均衡，除此之外，还有客户端负载均衡，比如 Spring Cloud 的 Ribbon 组件。客户端负载均衡和服务端负载均衡的核心差异在于谁感知可用服务列表，进行负载均衡操作，客户端进行上述操作的就是客户端负载均衡，反之则是服务端负载均衡。

在客户端负载均衡中，客户端实例都有一份自己要访问的可用服务端地址列表数据，这些列表可从服务注册与发现中心获取，然后根据负载均衡算法选择一个实例，使用其 IP 地址来发送请求。而在服务端负载均衡中，可用服务端地址列表数据只存在于负载均衡集群中，客户端往往只能通过固定IP地址来进行调用。二者的区别如下图所示：


## 算法简介
随机法。该算法是随机从可用服务列表中选取一个服务实例来分发请求。它的实现非常简单，一定程度上保证了请求的分散性，但是无法顾及请求分配是否与服务实例的负载能力相符合，并且存在偶发的突然分发大量请求到同一服务实例的毛刺问题。

轮询法或者加权轮询法。该算法将请求轮流分配给现有可用服务列表中的每一个服务实例，适用于集群中服务实例的负载能力大致相同且请求处理能力差异不大的场景。而改进的加权轮询则会根据各个服务实例的权重，额外分配给权重较大者相适应的更多请求，例如服务A权重为1，服务器B的权重为2，服务器C的权重为3，则使用加权轮询算法进行负载分配的过程可能为A-B-B-C-C-C-A-B-B-C-C-C。

Hash 法或者一致性 Hash 法。该算法根据请求的某些属性（比如说userId），使用Hash算法将其分散到不同服务实例中，这样保证了相同属性的请求会被转发到相同的服务实例中，可以更好地利用缓存，提高系统的整体性能。改进型的一致性Hash法则基于虚拟节点，在某一个服务实例宕机或不可用后能将请求平摊到其他服务节点，避免请求分发的目标实例发生剧烈的变化，影响系统的整体处理性能。
4.最小连接数法。该算法将请求分配到当前可用服务列表中正在处理最少请求的服务实例上。该算法需要负载均衡服务器和各个服务实例之间进行一定量的信息交互，负载均衡服务器还需要了解集群中各个服务的负载情况，这样可以动态地根据服务的负载数据，更好地调控分配比例，提升系统整体性能。


## 关键点
* 公平性
* 正确性,即对于有状态的服务来说
* 

## 算法
### 半状态的负载均衡
#### 一致性哈希
一致性 Hash 和 Hash 策略最大的区别在于，一致性 Hash 是对固定值 232 求模，不会随着机器数量的变化而变化，所以对于同一个 Request ID ， iRequest 是始终稳定不变的，这样就解决了 Hash 的策略在实例数量发送变化后，几乎所有的分配关系都会发生变化的问题。
##### 数据分片
### 全状态的负载均衡

全状态的负载均衡一般以路由服务的形式存在，在路由服务里面，都会存储后端实例 ID 和状态信息的索引，在进行请求路由的时候，路由服务从请求的状态信息中获得索引的标识，通过查询索引获得后端实例的 ID，然后再进行路由。


## 资料
[05｜负载均衡：从状态的角度重新思考负载均衡
](https://time.geekbang.org/column/article/483663)
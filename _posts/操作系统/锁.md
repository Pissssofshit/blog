## 解决数据同步的四种方法
### 原子操作
问题：显然靠编译器自动生成原子操作不太可能。第一，编译器没有这么智能，能检测哪个变量需要原子操作；第二，编译器必须要考虑代码的移植性，例如有些硬件平台支持原子操作的机器指令，有的硬件平台不支持原子操作。

既然实现原子操作无法依赖于具体编译器，那就需要我们自己动手，x86 平台支持很多原子指令，我们只需要直接应用这些指令，比如原子加、原子减，原子读写等，用汇编代码写出对应的原子操作函数就行了

小结：
利用平台支持的原子指令，比如原子加、原子减，原子读写等，我们只需要直接应用这些指令，用汇编代码写出对应的原子操作函数就行了。

### 中断控制
中断是 CPU 响应外部事件的重要机制，时钟、键盘、硬盘等 IO 设备都是通过发出中断来请求 CPU 执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按下了键盘上的某个按键、硬盘已经准备好了数据
但是中断处理代码中如果操作了其它代码的数据，这就需要相应的控制机制了，这样才能保证在操作数据过程中不发生中断。
> 原子操作只适合于单体变量，对于复杂的数据结构是无法解决的。

实现原理:x86 CPU 上关闭、开启中断有专门的指令，即 cli、sti 指令，它们主要是对 CPU 的 eflags 寄存器的 IF 位（第 9 位）进行清除和设置

嵌套问题
解决方法:
调用cli之前先保存eflags寄存器，然后在执行结束之后恢复保存的eflags寄存器就可以了

### 自旋锁
> 多cpu（有多条代码执行流)的场景下,上述的中断控制方法就失效了（因为中断控制是在当前cpu上生效的，没有办法控制其他几个cpu)

回到第一个方法，它的限制是只能简单的数据类型

还是从硬件上找解决方案

TODO linux自旋锁实现

缺陷: 不适合长时间等待

### 信号量

要解决的问题: **等待、互斥、唤醒**




---
title: 聊聊ACID中的A
category: [数据库]
tags: [数据库,ACID]
layout: post
---
ACID代表原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这些是事务处理的四大基本属性。今天让我们来聊聊ACID中的A。
原子性是ACID属性中的第一个属性，确保事务被视为一个不可分割的最小工作单位。在事务中，所有的操作要么全部完成，要么全部不完成。MySQL的InnoDB存储引擎通过日志和锁两大机制来确保原子性。
## 日志
### redo log
redo log记录了对数据库进行修改的操作，以便在数据库发生崩溃时可以利用这些记录恢复未写入磁盘的数据。redo log是循环写入的，分为两个主要部分：一是内存中的redo log buffer，用于缓存日志记录；二是磁盘上的redo log files，用于持久存储。
redo Log 主要用于确保事务的持久性。它记录了事务所做的修改，以便在系统崩溃后能够重新应用（redo）这些修改，恢复到崩溃前的状态。这是通过预写日志协议（Write-Ahead Logging, WAL）来实现的，确保在修改实际写入数据库之前，先写入日志。具体来说，当事务执行数据变更操作（如INSERT、UPDATE或DELETE）时，这些变更首先被记录在内存中的redo log buffer里，而不是直接写入到数据文件。这样做的目的是为了快速记录变更，同时减少磁盘I/O操作，提高性能。只有当事务成功提交时，redo log buffer中的内容才会被刷新（写入）到磁盘上的redo log files中。之后，这些变更会在适当的时机异步地被应用到数据文件上。这个过程保证了即使发生系统崩溃，已提交的事务所做的变更不会丢失，因为可以从redo log files重做（redo）这些变更。
### undo log
undo log用于存储旧的数据版本。这主要是为了满足两个目的：一是为了实现MVCC（多版本并发控制），从而允许在同一时刻对同一数据有多个可见版本(undo log 有一个版本链) ;二是为了在事务失败或被明确回滚时，能够撤销已经做出的更改。
每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：
- 在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；
- 在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；
- 在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。
Undo Log 对实现原子性至关重要。它记录了事务执行前的数据状态，如果事务失败或需要回滚，MySQL可以利用undo log来撤销（undo）已执行的修改，将数据恢复到事务开始前的状态。

### binlog 和 redo log
在事务提交的过程中，redo log和binlog的写入顺序如下：
先写redo log：当事务执行过程中进行修改操作时，首先将这些修改操作记录到redo log buffer中。在事务提交时，先将redo log buffer中的内容刷新到redo log files中，这个过程称为“prepare”阶段，确保了即使在此之后服务器崩溃，事务的修改也能够通过redo log进行恢复。
后写binlog：一旦redo log被成功写入磁盘，接下来MySQL会写入binlog。这时，事务的修改已经安全地记录在redo log中，确保了事务的持久性。
再次写入redo log：完成binlog的写入后，InnoDB存储引擎会再次访问redo log，这次是为了标记事务为"commit"状态，这个步骤确保了事务的原子性和持久性。
这个顺序是基于一种称为“预写日志协议”（Write-Ahead Logging, WAL）的策略，目的是确保即使在事务提交过程中发生崩溃，系统也能够根据日志恢复到一致的状态。这种写入顺序，先写redo log确保了事务的持久性，随后写binlog确保了数据的可恢复性和复制的可能性。
所以，简单来说，当事务进行更改时：
- 更改首先记录在redo log中，以确保更改的持久性。
- 被更改的数据的原始版本存储在undo log中，以支持回滚操作和MVCC。
先写redo log file 再写binlog 再写 redo log file 的这种策略也是二阶段提交的一种实现。
什么是二阶段提交？解决的是什么问题？
两阶段提交（2PC）：这是一个确保在分布式系统中事务原子性的协议。MySQL在事务处理中使用了类似的机制，确保redo log和binlog之间的一致性。在第一阶段（prepare阶段），事务的修改被写入redo log并准备提交。此时，事务还未标记为提交，因为binlog还未写入。
## 锁
锁在数据库系统中主要是用来维护事务的隔离性，防止不同事务间的干扰，例如更新丢失、脏读、不可重复读和幻读等问题。然而，通过控制事务对数据的并发访问，锁机制也间接地对事务的原子性提供了支持。下面是锁与原子性及隔离性之间关系的详细解释：
- 事务的完整执行：原子性要求事务中的操作要么全部完成，要么全部不完成。锁通过确保事务在执行过程中对必要资源的独占访问，帮助保证事务可以在没有外部干扰的情况下完整执行。如果事务在获取所需的所有锁之后因为某些原因（比如错误或冲突）无法完成，那么事务会被回滚，所有已经获取的锁会被释放，事务对数据的所有修改也会被撤销，从而维持了原子性。
- 回滚与恢复：在执行事务回滚时，锁确保在恢复到事务开始前的状态期间不会有其他事务干扰，从而保持了操作的原子性。
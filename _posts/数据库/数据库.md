---
title: Mysql
category: 数据库
layout: post
---

# 存储引擎

## 
MyISAM
```
不支持事务，但是每次查询都是原子的；

支持表级锁，即每次操作是对整个表加锁；

存储表的总行数；

一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；

采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
```

InnoDb
```
支持ACID的事务，支持事务的四种隔离级别；

支持行级锁及外键约束：因此可以支持写并发；

不存储总行数；

一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里）

也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；

主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；

因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；

最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。
```

# 存储
## 数据页
InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。

### 结构
文件头：各种页通用的信息，比如页的类型是什么、页的编号是多少、上一页的页号是多少、下一页的页号是多少等等
页头：主要记录数据页的一些信息，比如本页存了多少条记录、页目录中有多少个槽等等
最小和最大记录: 指向最大最小地址
用户记录: 将所有的记录划分成几个组(TODO 划分方法),记录组从小到大以单链表连接,最后一条记录的头信息中会存储该组一共有多少条记录
用户空间: 用于存储用户记录
页目录: 相当于一个数组，每个数组元素指向各个数据组的最大记录
文件尾：主要用于校验一个页是不是完整的

这样的结构设计是结合了两种数据结构的优点
链表+数组 = 高效添加删除+二分查找

## 索引设计

### 怎样的索引是好索引
由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。

所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。

另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。

所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：

能在尽可能少的磁盘的 I/O 操作中完成查询工作；
要能高效地查询某一个记录，也要能高效地执行范围查找；

### 聚簇索引和二级索引

聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；
二级索引的叶子节点存放的是主键值，而不是实际数据。

### B+树
TODO

## 事务
TODO

### 事务是如何实现的
#### 隔离等级
read uncommited ：读到未提交数据
read committed：脏读，不可重复读
repeatable read：可重读
serializable ：串行事物


## 锁

### MVCC
https://segmentfault.com/a/1190000037557620

Q
1. LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称
LAST_INSERT_ID 并发情况
2. explain 意义

3. 你们数据库是否支持emoji表情，如果不支持，如何操作？
如果是utf8字符集的话，需要升级至utf8_mb4方可支持

超键、候选键、主键、外键分别是什么？


1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。


2、候选键：是最小超键，即没有冗余元素的超键。


3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。


4、外键：在一个表中存在的另一个表的主键称此表的外键

作者：Java_老男孩
链接：https://juejin.cn/post/6844903824935632909
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

说一说三个范式。

第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。
第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

作者：Java_老男孩
链接：https://juejin.cn/post/6844903824935632909
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
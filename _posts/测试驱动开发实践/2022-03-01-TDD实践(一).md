---
title: TDD实践(一)
category: [TDD]
tags: [TDD]
layout: post
---

## 什么是TDD?
维基百科是这样介绍TDD的
```
测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。

测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。
```
TDD的三项法则
1. 在编好失败单元测试之前，不要编写任何产品代码。
2. 只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败。
3. 产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。

## 如何推销TDD给你的同事和领导
处于团队之中，想要实践一项技术，首先要说服你的同事和领导，否则后续很难推进下去。于是我跟他们列举了TDD的好处:
* 在编写代码之前指出代码的预期行为,**从而在验证实现之前先验证设计**
* 帮助开发者专注于实现用户的实际需求，防止过度设计
* 有助于代码模块化
* 自动化测试保护回归，是重构代码的基础

但是收到的反馈普遍不佳，大致分为两类：
1. TDD意义不大
2. TDD成本很高,难以实施

对于第一条，我很难认同，因为我手上有许多老项目，代码逻辑奇葩冗余,新增或修改时要万分小心,可即使如此还是时常陷入修改了一点边角料却导致意料之外的问题的窘境。而TDD正能解决这个问题。
那么他们又是怎么写代码，怎么保证代码的正确性的呢？经过进一步沟通，他们大致是这样一个流程：
1. 代码分层，将业务逻辑拆分到相应的模块中
2. 细化各个层次代码的入参出参以及异常情况处理
3. 思考验证代码是否正确的场景

我恍然大悟，虽然他们嘴上拒绝了TDD，但是实际上他们在下意识的做着TDD。我把这种方式称为思维上的TDD。
对于相对有经验的开发者来说，思维上的TDD足以应对大部分的情况，实际开发中也相对够用。可真正致命的是:他的思考过程仅存留与他的大脑里，没有文档或者代码化。这导致在生产代码写出来之前，没有人(甚至包括他自己)能全面验证设计是否有问题，并且在面对需求变更时，很难把握变更的影响范围(而这又可能影响整个系统的设计),并且长期来看，项目最终会变为我手上的“老项目”之一。

## 实践开始
经过考虑，我打算以手上的一个老项目实践TDD,并将该项目的代码测试覆盖率达到100%写入了绩效目标之中，理由如下:
* 这个项目的代码写的很丑，我时常想着重构，可是当下没有文档没有测试用例不敢动， 给这个项目补上之后就可以放开手脚重构了
* 需求量适中，工期不会很赶，有相对充裕的时间补充测试用例
* 这个项目会下发任务到设备跑任务，跑单次任务耗时一小时以上，一旦出现bug会严重耽误用户，所以回归测试非常必要
> 后来发现覆盖率100%很荒唐,纯粹是给自己挖坑

### 项目代码分析
这个项目采用的是常见的MVC结构,基本上业务逻辑全部写在service层。而service方法大多都是面条式的代码:从用户界面到数据库的逻辑全部写在一个方法里。这给测试造成了很大的困难:
* 一个方法负责的逻辑太多了，关注的逻辑层次很多
* 方法内创建了许多新对象，这些对象的行为是不受控制的
* TODO

### 实践结果
最终本次实践惨痛的失败了，总结如下:
* 需求总会有变动，原本一次修改代码，现如今需要改完测试用例再改代码，最终不胜其烦，甚至到了影响开发进度的程度。这让我最终放弃了更新测试用例，以至于项目中留下了一堆不可用的测试残骸(那一堆报红的用例!)
* 编写的测试代码的可读性太差，没有按照场景编写，同生产代码一样，在一段时间之后，测试代码也不可读了，由此失去了它应有的价值
* 因为代码本身难以测试，很多情况覆盖不到，最终还是需要手工验证
* TODO add more

这次失败的尝试给我留下了两个问题
1. 怎么写出可测试的代码
2. 怎么写出可维护的测试 

## SOLID
SOLID是检验代码设计合理性的重要原则，这次实践让我对其的认识重新认识了。五大原则列举如下
* 单一职责原则（Single Responsibility Principle，SRP）是指“类发生变化的原因应该只有一个”。换句话说，类要小而专注，并具有高内聚。不止如此，方法应该只有一个变化的原因。这就是Sandro Mancuso所称的内部视角
* 开闭原则（Open-Closed Principle，OCP）认为类应当“对扩展开放，但对修改关闭”。尽管听起来很抽象，其实就是说在不改变源代码的情况下去改变类的行为，例如，替换不同的策略
* 里氏替换原则（Liskov Substitution Principle，LSP）是指“子类应该能替换掉父类”。也就是，使用类A实例的代码，如果传入其子类B的话，它还能正常工作。
* LSP是关于合理存在的类继承关系，它体现为有效的抽象，而不仅仅是为了方便而进行的代码复用。尽管从可测性角度看，它在SOLID原则中不是最重要的，但违反LSP也意味着崇尚测试的程序员受到束缚。遵循LSP的类继承关系通过使用契约测试 （contract test）来提高可测性——为一个接口编写的测试，可以用于该接口的所有实现”
* 接口隔离原则（Interface Segregation Principle，ISP）表明“许多具体的客户接口要好过一个宽泛的接口”。简言之，你应该保持接口小而专注。
* 第五个SOLID原则是依赖反转原则（Dependency Inversion Principle，DIP），是说代码应该“依赖于抽象，而非细节”。极端地说，DIP认为类不应该实例化自己的协作者，而是传入它们的接口”

让我们从测试的角度重新审视SOLID。当你的代码无法测试时，请问自己如下几个问题:
* 是不是类/方法承担了太多职责(违反了单一职责原则)导致有太多需要变更的理由?
* 是不是违反了依赖反转原则，在方法中自行实例化了自己的协作者导致无法控制协作者进而难以构造出测试条件进而无法测试？
* TODO add more

对我来说，这几个问题的答案是:是的!

# 测试理念
测试一个对象，就是观察它在对应的输入下的输出是否符合预期。

输出包括:
1. 与其协作者的交互
2. 自身状态的改变

对于第一点，一定要注意给定协作者指定的输入并不一定会给出符合预期的输出，比如网络调用失败、数据库异常等，因此异常响应的情况也必须包含在测试用例中。这就要求在测试中对对象的协作者达到完全的“控制”。怎么达成呢？答案是使用依赖注入与mock。

第二点，因为我们是面向接口编程，我们不能通过直接读取对象的值的方式来判读对象状态是否正确，所以对于必要的状态，我们要在接口中专门定义一个读取状态的方法。

# 总结
在代码设计上
1. 类/方法承担单一职责
2. 面向接口编程
3. 接口保持小巧
4. 类不主动实例化协作者而是传入接口
> 为了更合理划分模块/类的方法，后来还深入学习并实践了领域驱动设计

在测试设计上

1. 只
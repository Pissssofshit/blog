---
title: 工作流系统
category: [项目]
tags: [工作流]
layout: post
---

工作流系统是一种用于管理和协调复杂业务流程的软件系统。它将一个复杂的业务过程拆分为一系列的任务和步骤，并规定它们的执行顺序、依赖关系和条件。工作流系统通过自动化执行、监控这些流程，使得业务流程的管理更加简单、可靠和高效。
工作流系统由以下几个部分组成:
1. 建模工具（前端UI）
职能：允许用户以图形化的方式设计和修改业务流程。这些工具提供拖放界面，使非技术用户能够创建和调整流程定义，包括任务、决策点、事件等。建模规范遵照BPMN。
2. 流程引擎
职能：流程引擎是工作流系统的核心，负责执行由建模工具设计的流程定义。它管理流程实例的生命周期，包括启动新实例、执行任务、处理用户交互、管理流程状态。
流程引擎的开源框架已经很多很成熟了，为什么选择自研？
这个系统是我们平台非常核心的一个服务，它需要满足高度定制的业务需求，会进行不断的迭代， 如果采用开源流程引擎的初始成本可能较低，但长期来看，定制、维护和升级开源解决方案的成本可能会增加。
3. 规则引擎
职能：规则引擎允许定义和执行业务规则，这些规则可以在流程执行期间评估和应用。规则引擎与流程引擎紧密集成，使得业务逻辑可以从流程定义中分离出来，实现更灵活的决策和条件逻辑。
4. 任务管理和用户界面
职能：提供用户界面供最终用户执行流程中的任务，查看待办事项，以及管理和监控流程实例。这些界面通常需要与流程引擎紧密集成，以实现任务分配、通知和协作功能。

### 主要技术难点
工作流系统面临的主要技术难点是如何设计一个既能处理复杂多变业务流程又能保证流程可靠执行的流程引擎，并且需要保证高性能和可拓展性。
> 需要满足不同业务线不同的需求，需要足够的灵活，尽量避免硬编码
### 应对复杂多变业务流程
提供功能丰富的节点，比如用户任务（人工任务）、服务任务（自动化任务，调用外部服务），服务任务节点支持注册回调（前端提供UI，填入服务名、方法，参数是统一的（流程节点的信息))、动态节点
动态节点行为通常需要流程引擎提供强大的表达式求值能力，支持访问流程上下文中的数据，以及与外部系统的集成能力，以便于获取和处理外部输入

#### 动态决策
业务流程中复杂的决策树和条件分支要求流程引擎能够在运行时根据输入数据动态地决定下一步骤。这意味着流程引擎必须能够解析和执行复杂的逻辑表达式，
这部分可以抽离出一个规则引擎，负责专门的规则管理、表达式的解析
并根据动态数据和预先定义的规则做出决策。实现这种动态决策是技术上的难点。

##### 业务规则引擎
规则引擎主要的一个技术难点在于规则表达式的解析，发展到一定程度，需要实现自己的领域语言。
我们的项目目前还不到这一步，对于我们当前业务，基本的表达式大于等于、包含不包含这些表达式已经足够满足
将规则的管理、动态决策的功能抽离为业务规则引擎主要是为了解决以下几个问题：
**分离业务逻辑与流程控制**
在复杂的业务流程管理中，业务逻辑（如决策树、条件分支）和流程控制（如流程的启动、暂停、终止）往往紧密交织在一起，这不仅使得流程设计变得复杂，而且当业务规则发生变化时，也需要重新设计和部署流程。集成业务规则引擎可以将业务逻辑抽象出来，单独管理，使得流程设计更加简洁和灵活。
**规则管理和维护**
随着业务规则数量的增加，规则本身的管理和维护变得复杂。设计一个易于理解、易于维护的规则管理系统是流程引擎设计的一个关键点。
业务规则可能会随着市场环境、政策法规的变化而频繁变更。如果这些规则硬编码在流程逻辑中，每次规则变更都可能需要修改流程定义，测试并重新部署，这不仅耗时耗力，也增加了出错的风险。通过使用业务规则引擎，可以实现规则的外部化配置和动态加载，使得业务规则的更新不再需要修改流程本身，提高了系统的灵活性和响应速度。
>由于我们没有抽象出专门的规则引擎做做规则管理，我们采用的设计是将规则配置与流程节点信息放置在一起，这样执行到具体节点的时候，同时可以拿到当前节点配置的规则

**提高决策的精确度和一致性**
复杂的决策逻辑可能需要根据大量的输入参数进行细粒度的条件判断。在没有规则引擎的情况下，这些逻辑可能需要通过复杂的编程实现，容易出错且难以维护。业务规则引擎提供了一种更加直观和灵活的方式来定义、管理和执行这些决策逻辑，可以确保在整个组织中做出一致且准确的决策。
简而言之，业务规则引擎的抽离有以下好处：
- 规则的中心化管理：业务规则引擎允许以声明式的方式定义业务规则，并将这些规则集中存储在一个易于访问和管理的位置。这样，当业务逻辑需要更新时，只需更改规则配置而不需要修改和重新部署流程应用。
- 动态规则评估：在运行时，流程引擎可以调用业务规则引擎评估当前的业务数据，根据评估结果动态决定流程的执行路径。这种动态决策支持使得流程能够灵活应对各种业务场景。
- 提供复杂决策支持：业务规则引擎支持复杂的逻辑判断、条件分支和循环等结构，使得设计复杂的业务逻辑成为可能。此外，许多业务规则引擎还提供了仿真、测试和决策分析的功能，帮助业务分析师和开发人员验证规则的正确性和有效性。
实现动态决策的底层原理
底层原理通常涉及将表达式解析成一个抽象语法树（Abstract Syntax Tree, AST）。AST是一个重要的数据结构，用于表示编程语言中的构造（如变量、操作符、函数调用等）以及它们之间的关系。这种表示方法允许程序以结构化的方式理解和执行代码或表达式。下面是这个过程的大致步骤：
1. 词法分析（Lexical Analysis）
在这一步，表达式字符串被分解成一个个的"词素"（tokens），词素是表达式中最小的有意义的单元，如数字、字符串、操作符等。例如，表达式"creditScore > 700"会被分解成词素creditScore、>和700。
2. 语法分析（Syntax Analysis）
在词法分析之后，语法分析阶段将词素根据语法规则组装成树状结构，即AST。语法分析的过程依赖于预先定义的语法规则，这些规则描述了表达式中各个元素（如操作符、数字、变量等）的组合方式和解释方法。在我们的例子中，这棵树会有一个根节点表示操作符>，它有两个子节点：一个是变量creditScore，另一个是常量700。
为什么会将操作符>作为根节点呢？
语法分析过程遵循操作符的优先级和结合性规则来决定表达式的结构。例如，乘法和除法通常具有比加法和减法更高的优先级。解析器利用这些规则来决定哪个操作符应该成为当前子表达式的根节点。
构建AST：在解析表达式时，解析器根据操作符的优先级和操作数构建AST。在简单的creditScore > 700例子中，>是唯一的操作符，因此直接成为根节点，而creditScore和700作为操作数成为子节点。
3. AST遍历与评估
有了AST后，程序会遍历这棵树，根据节点类型和操作符执行相应的操作。对于条件表达式，这通常涉及到计算左右子节点的值，然后根据父节点的操作符来比较这些值。在评估过程中，变量的值会从上下文中获取，常量则直接使用。
假设有表达式"creditScore > 700"，解析和评估过程如下：
词法分析：分解成creditScore, >, 700
语法分析：构建AST，其中>是根节点，有两个子节点creditScore和700
评估：
查找creditScore在上下文中的值，假设为720
比较720 > 700
返回比较结果true

### 事务管理

#### 方案1
通过定义一套通用的补偿策略框架来实现补偿机制，这样就不需要直接在引擎中硬编码具体的业务操作。举个例子，支付的补偿操作是退款，如果硬编码，在代码中写死调用支付接口，失败则调用退款接口，这样显然是不够灵活的。
通用的补偿策略框架：
1. 定义操作配置：对于每个步骤，可以通过配置文件或数据库表来定义其正向操作和补偿操作所需的信息，包括调用的服务接口、所需参数、补偿操作的接口等。这样，流程引擎在执行操作时，仅需读取相应配置，然后根据配置动态调用指定的服务接口。
2. 使用操作标识符：在流程定义中，每个步骤的操作可以通过唯一标识符来引用外部配置的操作。这个标识符对应于某个具体的服务调用配置，包括了调用服务的URL、方法、参数模板、以及对应的补偿操作等。
3. 参数模板和替换：操作配置中的参数可以定义为模板形式，流程引擎在执行操作前，将根据当前流程上下文中的变量来填充这些模板参数，实现动态参数传递。
4. 补偿操作配置：与正向操作类似，补偿操作也通过外部配置来定义。流程引擎在需要执行补偿时，根据步骤的配置动态调用补偿操作。
下面还是用支付和退款做示例，其配置信息如下所示（示意性文本配置）：
```
{
  "stepId": "pay",
  "operation": {
    "url": "http://paymentservice.com/api/pay",
    "method": "POST",
    "bodyTemplate": "{\"amount\": \"{{amount}}\", \"account\": \"{{account}}\"}"
  },
  "compensation": {
    "url": "http://paymentservice.com/api/refund",
    "method": "POST",
    "bodyTemplate": "{\"transactionId\": \"{{transactionId}}\"}"
  }
}
```
在这个配置中，{{amount}}、{{account}}和{{transactionId}}是参数模板，会在运行时根据流程上下文中的变量替换为实际的值。
执行流程
1. 解析配置：流程引擎读取步骤配置。
2. 执行正向操作：根据配置调用远程支付服务，动态填充请求参数。
3. 记录事务日志：记录已执行的操作和待执行的补偿操作详情。
4. 失败时触发补偿：如果后续步骤失败，根据事务日志回查需要执行的补偿操作，并根据补偿操作配置进行调用。
这个方案虽然灵活，但是缺点也很明显：实现复杂、业务逻辑耦合太多（比如这里需要将远程支付服务的响应值transactionId记录下来，并在失败的时候用它进行补偿操作，不同的请求、传参方式可能会需要流程引擎这边进行适配。

#### 方案2
使用事务上下文
- 事务上下文传递：对于需要在正向操作和补偿操作之间传递的信息（如transactionId），可以设计一个通用的事务上下文结构。每当一个操作执行时，它可以将任何需要保留的信息存储在这个上下文中，而流程引擎负责将整个事务上下文在操作之间传递。
- 外部服务负责记录：在执行正向操作时，由该服务负责生成并返回需要在补偿操作中使用的信息（比如transactionId），然后将这些信息存储在事务上下文中。
实现流程
1. 流程节点执行：
  - 每个流程节点在执行时，会调用一个或多个外部服务来完成具体的业务操作。
  - 流程引擎为每个节点生成一个唯一的标识（比如节点ID），并将此标识传递给外部服务。
2. 外部服务记录状态：
  - 外部服务在执行业务操作时，根据接收到的节点ID，记录所有对后续可能需要进行补偿的信息。这可能包括事务ID、操作的具体内容、时间戳等。
  - 记录的信息应该存储在服务的持久化存储中，以便在需要时进行查询。
3. 补偿信息的关联：
  - 外部服务保证记录的补偿信息与流程的节点ID关联，确保在执行补偿时可以准确找到相关的信息。
4. 补偿操作触发：
  - 如果流程在后续步骤中遇到失败，需要回滚之前的操作，流程引擎将根据流程的节点ID，向外部服务发送补偿请求。
  - 外部服务接收到补偿请求后，根据节点ID查询之前记录的补偿信息，执行相应的补偿操作以回滚之前的业务操作。
> 我们实现的事务机制相当于1PC

### 异常处理和错误恢复
流程、节点都有自己的执行状态，在开始执行流程、某个节点时，首先会将节点状态更新为“执行中”，遇到节点异常会将节点状态更新为“失败”。有定时任务定时扫描“失败”和长时间处于“执行中”的流程，并做报警。并且做了错误日志的持久化，方便排查问题。

### 性能
引入了异步处理机制和消息队列，以减轻主流程引擎的负载，并通过缓存机制优化了频繁查询的处理




---
title: TCP(一)
category: [TCP]
tags: [TCP]
layout: post
---
### 什么是TCP
TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
- 面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- 字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。
粘包关系最大的就是基于字节流这个特点,字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间没有任何边界
#### 为什么需要 TCP 协议
因为TCP能“克服”网络包丢失及乱序的问题
TCP工作在应用层之下，IP层之上（网络层）
IP 层是"不可靠"的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
因此如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。
#### 为什么说TCP连接是可靠的
TCP（传输控制协议）被称为可靠的协议，是因为它提供了一系列的机制来确保数据准确无误地从发送方传送到接收方。这些机制包括：
1. 三次握手建立连接：在数据传输开始之前，TCP使用一种称为“三次握手”的过程来建立连接。这个过程确保了双方都准备好接收和发送数据，防止了数据传输的初始化状态下的不一致问题。
2. 序列号和确认应答：TCP为每个发送的数据包分配一个序列号，并要求接收方对数据进行确认应答。这意味着发送方可以知道哪些数据已被成功接收，如果某个数据包没有被确认，发送方可以重新发送该数据包。
3. 数据校验：TCP头部包含一个校验和字段，用于检查数据在传输过程中是否被损坏。如果数据包在传输过程中损坏，接收方可以丢弃该数据包，TCP将重新发送损坏的数据包。
4. 流量控制：TCP使用窗口大小（Window Size）来进行流量控制，确保发送方不会因为发送数据过快而淹没接收方。窗口大小可以动态调整，以匹配接收方的处理能力。
5. 拥塞控制：TCP还实现了拥塞控制机制，以避免网络中的过度拥塞。这包括慢启动、拥塞避免、快速重传和快速恢复等策略。当网络拥塞时，TCP会减少其数据传输速率，以减轻网络拥塞的程度。
6. 有序数据传输：TCP保证数据的顺序性。即使数据包在网络中以不同的速率和路径传输，最终到达接收方时，TCP也会根据序列号重新排序，确保数据按发送顺序进行处理。
7. 连接终止：TCP连接的终止也是一个双向关闭的过程，称为“四次挥手”。这个过程确保了双方都已完成数据的发送和接收，防止数据的丢失。
#### 报文格式
源端口和目的端口的字段（16位）:在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。
源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机
序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。
序列号生成规则:
确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。
控制位：
- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
### TCP连接
TCP的连接包含保证可靠性和流控制机制的信息，包括
- Socket：由IP地址和端口号组成
- 序列号：用来解决乱序问题等
- 窗口大小：用来做流量控制
唯一确定一个TCP连接的四元组：
<源地址,源端口,目的地址,目的端口>
### 三次握手
TCP三次握手过程是TCP/IP协议用来在两个主机之间建立一个可靠的连接的机制。它涉及序列号（seqid）和两端（客户端和服务器端）的状态变化。这个过程确保双方都准备好了数据的发送和接收。下面是三次握手的详细过程及参与者的状态变化：
第一次握手：SYN
1. 客户端发送SYN包：客户端选择一个初始的序列号（seq=X）并向服务器发送一个SYN（同步序列编号）包。这个动作标志着连接的开始。
  - 客户端状态变化：客户端从CLOSED状态变为SYN_SENT状态，表明正在尝试建立连接。
第二次握手：SYN-ACK
1. 服务器响应SYN-ACK包：服务器接收到客户端的SYN包后，选择自己的初始序列号（seq=Y），并向客户端发送一个SYN-ACK包。这个包中的ACK是对客户端SYN包的确认应答，ACK的值为客户端的序列号加一（ack=X+1），同时SYN标志位也被设置，表明这是一个连接请求。
  - 服务器状态变化：服务器从LISTEN状态变为SYN_RECEIVED状态，表明它已经收到了客户端的连接请求并做出了响应。
第三次握手：ACK
1. 客户端发送ACK包：客户端收到服务器的SYN-ACK包后，发送一个ACK包作为回应，这个ACK包中的序列号为初始序列号加一（seq=X+1），确认号为服务器序列号加一（ack=Y+1）。
  - 客户端状态变化：客户端在发送ACK响应后，状态变为ESTABLISHED，表明客户端到服务器的连接已经成功建立。
  - 服务器接收ACK包后的状态变化：服务器在收到客户端的ACK包后，也进入ESTABLISHED状态，表明服务器到客户端的连接也成功建立。至此，TCP连接建立完成，数据传输可以开始。
"客户端开始发送数据：如果客户端在发送最后一个ACK之后开始发送数据，这些数据包将会到达服务器。服务器在收到这些数据包时，会检查是否存在对应的半开连接（即服务器已发送SYN-ACK但未收到最终ACK确认的连接）。因为这些数据包的序列号将会基于之前客户端发送的ACK包中的确认号，服务器可以通过这些序列号确认客户端实际上已经接收到了SYN-ACK包，并且认为连接是建立的。"按这个说法，客户端的最后一次ACK包其实是不必要的？

“如果你不知道系统是如何失败的，那你就不知道系统是怎么运行的。”让我们来看下在三次握手过程中可能发生的异常及TCP的应对策略：
1. SYN包丢失
- 异常情况：客户端发送的初始SYN包在传输过程中丢失，未能到达服务器。
- TCP应对：客户端TCP实现会有一个超时重传机制。如果在特定的超时时间内没有收到服务器的SYN-ACK响应，客户端会重新发送SYN包。这个过程可能会重试几次，直到收到响应或达到最大重试次数。
2. SYN-ACK包丢失
- 异常情况：服务器响应的SYN-ACK包在传输过程中丢失，客户端无法接收到。
- TCP应对：客户端在发送SYN后会启动一个计时器，如果在超时时间内没有收到SYN-ACK，客户端会重新发送SYN包。服务器在收到重复的SYN包后，会再次发送SYN-ACK包。
3. ACK包丢失
- 异常情况：客户端发送的最后一个ACK包丢失，服务器无法确认客户端已经准备好进行数据传输。
- TCP应对：如果服务器没有收到最终的ACK确认，它仍然会在SYN_RECEIVED状态下等待一段时间。客户端在发送ACK后，如果已经进入ESTABLISHED状态，即使不接收到服务器的进一步响应也会开始数据传输。如果服务器长时间未收到ACK，可能会超时关闭连接，但通常在这之前，数据传输已经开始。
4. 延迟的包导致的异常
- 异常情况：有时，由于网络延迟，SYN或SYN-ACK包可能会在连接已经建立后到达，这可能导致不必要的重试和混乱。
- TCP应对：TCP协议实现中有机制来识别和处理旧的或重复的连接请求。例如，如果服务器收到一个旧的SYN包，它会检查该连接是否已经存在。如果连接已经建立，服务器可能会忽略该SYN包或发送一个RST（重置）包来明确告诉客户端连接已经存在。
5. 同时打开和同时关闭
- 异常情况：虽然不是严格的三次握手异常，但如果两个主机几乎同时发送SYN包尝试建立连接，或者同时发送FIN包尝试关闭连接，会进入一种特殊状态。
- TCP应对：TCP协议规定了如何处理这种情况，确保连接能够正确建立和终止。在同时打开的情况下，每个端都会接收到对方的SYN并回复SYN-ACK，然后双方都发送ACK。这实际上是一个扩展的握手过程，但最终能成功建立连接。
TCP通过这些机制确保即使在面对网络不稳定和数据包丢失的情况下也能可靠地建立和维护连接。
最后一个ACK包丢失的情况下，客户端认为TCP已经建立，但是服务端还没收到（此时服务器处于SYN_RECEIVED状态），那客户端怎么知道TCP连接有问题呢？只能等待服务端重发SYNC-ACK吗？如果客户端此时开始发消息了怎么办呢?
在最后一个ACK包丢失的情况中，确实存在一个潜在的通信不同步问题：客户端认为TCP连接已经建立并可能开始数据传输，而服务器因为没有收到最后的ACK确认，仍然处于SYN_RECEIVED状态。这种情况下，TCP协议的机制确保即使发生了这种不一致，通信仍然可以继续，尽量减少影响。以下是一些相关的处理细节：
1. 客户端开始发送数据：如果客户端在发送最后一个ACK之后开始发送数据，这些数据包将会到达服务器。服务器在收到这些数据包时，会检查是否存在对应的半开连接（即服务器已发送SYN-ACK但未收到最终ACK确认的连接）。因为这些数据包的序列号将会基于之前客户端发送的ACK包中的确认号，服务器可以通过这些序列号确认客户端实际上已经接收到了SYN-ACK包，并且认为连接是建立的。
2. 服务器的响应：当服务器在SYN_RECEIVED状态收到数据包时，理解到客户端已经处于连接建立状态，服务器可以将自身状态转换到ESTABLISHED，并处理收到的数据包。这样，即使最后一个ACK包丢失，连接也可以通过客户端发送的后续数据包来“自我修复”。
3. 重发SYN-ACK：在一些实现中，如果服务器在等待最后的ACK时收到数据包，它可能会再次发送SYN-ACK作为提醒，同时处理接收到的数据。如果客户端收到重复的SYN-ACK，它会重新发送ACK确认。这种机制帮助确保连接的同步状态，并且对数据传输的影响最小化。
4. 超时和重试：正如之前提到的，TCP在各个阶段都有超时和重试的机制。如果服务器长时间未从客户端收到预期的数据（包括最初的ACK确认），它可能会超时并关闭连接。然而，这种情况下，因为客户端已经开始发送数据，所以实际上的连接已经是有效的，服务器通过处理这些数据来“确认”连接的存在。
最后一个ACK包理论上可以和数据包一起发送，这样可以节省一次握手，在TCP协议中这被称为TCP快速打开（TCP Fast Open, TFO）的优化技术，以及一种概念上的优化，即将最后一个ACK包与首批数据一同发送的做法，这在某些情况下被称为TCP的“数据捎带”（data piggybacking）。
在传统的TCP三次握手过程中，第三次握手（即客户端发送给服务器的ACK响应）确实是必要的，它标志着连接的建立完成。然而，理论上，如果客户端在发送这个ACK的同时也有数据要发送给服务器，那么它可以将数据直接附加在ACK包中一起发送。这样做的好处是减少了通信的延迟，因为它合并了建立连接的最后一步和数据传输的第一步。
这种做法在某些TCP/IP协议栈实现中是允许的，特别是当立即有数据需要发送时。它有效地利用了TCP连接的建立过程，减少了往返时间（RTT）和潜在的延迟。
TCP快速打开（TFO）是TCP协议的一个扩展，它允许数据在TCP三次握手的第一次握手（SYN包）中被发送，进一步减少了建立连接所需的往返时间。这是一种更为明显的优化，允许在连接建立的过程中传输数据，而不是等到三次握手完全完成后。TFO需要客户端和服务器都支持这一扩展，服务器需要向客户端提供一个TFO cookie，在后续的连接尝试中，客户端可以携带这个cookie以证明其之前成功建立过连接，允许在SYN阶段携带数据。
#### 为什么要三次握手建立连接？
假设只进行两次握手：
1. 客户端发送 SYN 到服务器请求建立连接。
2. 服务器接收到 SYN 并回复 SYN+ACK。
在这个模型中，你正确地指出，当客户端收到 SYN+ACK 时，它确实知道服务器已经准备好了。但这里的核心问题是，服务器不会知道其 SYN+ACK 是否被客户端成功接收。换句话说：
- 如果 SYN+ACK 丢失或在网络中延迟，服务器会认为连接已经建立，而客户端则不会。
- 这可能导致服务器等待客户端发送数据，而客户端则什么都不做，因为它认为连接还没有建立。
如果TCP建立连接只通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求。
而在不稳定的网络环境中构建一个可靠的传输层,常见的问题有:
- 数据包被发送方多次发送造成数据的重复（服务端如果选择接受，那么会造成重复的连接）
- 数据包在传输的过程中丢失
- 数据包不能有序到达接收方
这意味着当发送方多次请求时，接收方需要建立多个连接
这会带来什么实际问题呢？
历史连接问题
如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求,而由于网络包是无序的，旧的连接请求先于新的连接请求导到服务端。然而按照我们上面设想的“两次挥手”模式，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是仍然有效的（必须由发起方来做确认）。
所以在实际的TCP连接建立的过程中，接收方会将发送方连接请求中包含的 序列号+1 发送回发送方，并交由发送方来判断该请求是否有效：
- 如果当前连接已经失效，那么发送方就会直接发送 RST 控制消息中止这一次连接；
- 如果当前连接仍然有效，那么发送方就会发送ACK控制消息，通信双方就会成功建立连接；
三次握手的方式将最终是否建立连接的最终控制权交给发送方，因为只有发送方有足够上下文来判断当前连接是否是错误的或者过期的，这也是TCP使用三次握手建立连接的最主要原因
网络包缺失或无序问题
另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：
- 数据包被发送方多次发送造成数据的重复；
- 数据包在传输的过程中被路由或者其他节点丢失；
- 数据包到达接收方可能无法按照发送顺序；
为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：
- 接收方可以通过序列号对重复的数据包进行去重；
- 发送方会在对应数据包未被 ACK 时进行重复发送；
- 接收方可以根据数据包的序列号对它们进行重新排序；
举一个网络包缺失或无序问题的例子
1. 客户端（C） 发起一个连接请求给 服务器（S），发送了一个包含序列号X的SYN包，但这个包在网络中延迟了，没有立即到达服务器。
2. 客户端没有收到回应，可能因为超时或其他原因，决定重新启动一个新的连接请求，这次发送了一个包含新序列号Y的SYN包。
3. 第二个SYN包正常到达服务器，服务器回应一个SYN-ACK包，并认为连接已建立。
4. 此时，第一个延迟的SYN包到达服务器。如果我们只有二次握手，服务器可能会认为这是一个新的连接请求，因为它带有不同的序列号X。服务器可能会回应并更新其对连接的认识（比如重置序列号），而客户端可能还在使用基于序列号Y的连接。

由于客户端和服务端此时持有的序号不同，后续的交换就变得混乱了
### 四次挥手
TCP四次挥手过程是用来终止一个TCP连接的机制。这个过程涉及四个步骤，确保双方都能清楚地关闭连接，同时处理好任何还在传输中的数据。下面详细介绍这四个步骤及其涉及的序列号（seqid）和确认号（ack），以及客户端和服务器端的状态变化。
第一次挥手：FIN从客户端发送到服务器
1. 客户端发送FIN包：当客户端完成数据发送任务后，它需要发送一个FIN包给服务器，表示客户端已经没有数据发送了，请求关闭连接。这个FIN包包含一个序列号（seq=X），这个序列号是客户端待发送数据的下一个序列号。
  - 客户端状态变化：客户端从ESTABLISHED状态变为FIN_WAIT_1状态，表示它已经发送了连接终止请求。
第二次挥手：服务器确认客户端的FIN
1. 服务器响应ACK包：服务器接收到客户端的FIN包后，发送一个ACK包作为回应，确认号设置为客户端的序列号加一（ack=X+1），表示服务器已经接收到客户端的终止请求，并同意关闭连接。
  - 服务器状态变化：服务器从ESTABLISHED状态变为CLOSE_WAIT状态。
第三次挥手：服务器发送FIN到客户端
1. 服务器发送FIN包：服务器在完成它的数据发送任务后，发送一个FIN包给客户端，用来关闭服务器到客户端的数据传输。这个FIN包包含一个序列号（seq=Y）。
  - 服务器状态变化：服务器从CLOSE_WAIT状态变为LAST_ACK状态，等待客户端的最后确认。
第四次挥手：客户端确认服务器的FIN
1. 客户端响应ACK包：客户端接收到服务器的FIN包后，发送一个ACK包作为回应，确认号设置为服务器的序列号加一（ack=Y+1），表示客户端已经准备好关闭连接。
  - 客户端状态变化：客户端从FIN_WAIT_1状态变为FIN_WAIT_2状态，然后在收到服务器的FIN包后进入TIME_WAIT状态。客户端在TIME_WAIT状态等待足够的时间以确保服务器接收到了最后一个ACK包，然后关闭连接。这个等待时间通常是最大报文段生存时间（Maximum Segment Lifetime, MSL）的两倍。
为什么挥手需要四次？
关闭连接的过程跟打电话很类似，
A: 我说完了，我准备挂了(FIN)
B: 知道了。（ACK)
A内心OS: 你还有什么要说的吗？我等着呢
B: 那我也挂了 （FIN)
A: 知道了 （ACK)
- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
这个用专业一点的话来说就是：
TCP连接是全双工的，即数据可以在两个方向上独立地传输。因此，每个方向的关闭都需要单独的请求和确认。
拓展： TCP挥手可以变成三次吗？
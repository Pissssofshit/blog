## 基本概念

### 状态码

2xx 成功，报文已收到并被正确处理

3xx 重定向

4xx 客户端错误，请求报文有误，服务器无法处理

5xx 服务器错误，服务器再处理请求时内部发生了错误

### 常见字段

### 报文

HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文

- [ ] 因为HTTP报文是面相文本的，所以字段这些都是用空格、回车符、换行符这些来分隔判断的？

#### 请求报文

一个HTTP请求报文由**请求行**、**请求头部**、**空行**和**请求数据**4个部分组成，下图给出了请求报文的一般格式

TODO 补充请求报文表格（图)

#### 响应报文

HTTP响应由三个部分组成，分别是：**状态行、消息报头、响应正文**。

* 状态行：{版本,状态码,短语}
* 消息头:[{首部字段名,字段值}]
* 消息体: 数据

### 传输数据大小限制

   首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：

   GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

   因此对于GET提交时，传输数据就会受到URL长度的限制。

   POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。

## 缓存技术

### 强制缓存

* 浏览器第一次请求访问服务器资源，服务器响应头加上 Cache-Control（优先级高于Expires),Cache-CControl设置了过期时间大小
* 浏览器再次请求该资源之前，会先通过请求资源的时间与Cache-Control中设置的过期时间大小来计算出该资源是否过期
* 服务器再次收到请求后，会再次更新Response头部的Cache-Control

### 协商缓存

强制缓存在缓存有效期内，无论服务器资源是否已经实质上更新了，都会使用本地缓存。

协商缓存则是会询问服务器，我本地的缓存资源是否需要更新/继续使用呢？所以称之为协商缓存.

协商缓存可以基于两种头部来实现：

1. 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现 （比较修改时间)
2. 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段 （比较文件内容)

## 性能

HTTP 协议是基于  **TCP/IP** ，并且使用了「 **请求 - 应答** 」的通信模式，所以性能的关键就在这**两点**里

* 长连接
  减少三次握手四次挥手造成的开销
* 管道网络传输

  管道网络传输是指在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

  但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**

  如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

  所以， **HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞** 。

  要解决队头堵塞的根本方式是**多路复用**，即同时处理多个流/io/请求？

  这在 HTTP/1.1 中是不可能的，因为**没有办法分辨一个块属于哪个资源，或者它在哪里结束，另一个块从哪里开始。**

#### 为什么不可能呢？HTTP报文明明指明了报文长度的呀？

通过报文长度判断有没有接受完整的报文的前提就是顺序发送请求，才能通过判断读取到的数据是否已经足够了。不然把不同HTTP请求的TCP报文拼接成同一个了。HTTP/2通过在资源块前添加了数据帧，这些数据帧包含了两个关键的元数据:

1. 唯一的stream id 标识这个包属于哪个资源
2. 包的大小是多少

使用这些帧，HTTP/2 确实允许在一个连接上正确地复用多个资源

> 这个机制允许了HTTP/2在一个TCP连接上并发多个请求，应用程序可以在接受到TCP包之后重新组装成完整的HTTP报文。算是。

### [tcp粘包](https://segmentfault.com/a/1190000039691657)

## HTTP1.1的缺陷

- [ ] 这段算是总结的，每个论点都要去把论据给找出来

* 延迟难以下降，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；

  - [X] 为什么HTTP1.1的延迟难以下降？ HTTP1.1的性能问题出在哪里？
    - [ ] 队头阻塞
      - [ ] [关于队头阻塞（Head-of-Line blocking），看这一篇就足够了](https://zhuanlan.zhihu.com/p/330300133)
        好文
* 并发连接有限，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；
* 队头阻塞问题，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；
  HTTP 头部巨大且重复，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 cookie 的头部，而 cookie 的大小通常很大；
* 不支持服务器推送消息，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。

**而一些关键的地方是没办法优化的，比如请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等，要改变这些必须重新设计 HTTP 协议，于是 HTTP/2 就出来了**

HTTP1.1不支持多路复用，要解决队头等待

我们希望能够正确地复用资源块（resource chunks）。这在 HTTP/1.1 中是不可能的，因为**没有办法分辨一个块属于哪个资源，或者它在哪里结束，另一个块从哪里开始。**

HTTP2是怎么做的？

HTTP/2 在每个块前面放置一个所谓的数据帧（DATA frame）。这些数据帧主要包含两个关键的元数据。首先：下面的块属于哪个资源。每个资源的“字节流（bytestream）”都被分配了一个唯一的数字，即 **流id（stream id）** 。第二：块的大小是多少。协议还有许多其他帧类型，图5也显示了头部帧（HEADERS frame）。这再次使用流id（stream id）来指出这些头（headers）属于哪个响应，这样甚至可以将头（headers）从它们的实际响应数据中分离出来。


HTTP/2在语义上没有改动(请求头、状态码、头字段等规则)，在语法上做了很多改造，基本改变了HTTP报文的传输格式

### 头部压缩

#### 为什么要进行头部压缩

HTTP协议由Header + Body构成

- [ ] HTTP1.1的报文格式是怎么样的
- [ ] Header Body 换个说法咋说
- [ ] 动态表是怎么添加的？第一次是怎么把header传过去的？
  [HTTPS动态表](https://segmentfault.com/q/1010000041490036/a-1020000041491855)
  **请求头与响应头的分帧，中间不能插入其他分帧**
- [ ] HTTP2 的Stream是什么,HTTP2为什么能多路复用，为什么HTTP1.1不能有流的概念/不能多路复用/为什么要基于请求-响应模型
- [ ] HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，为什么是这样?

1. 固定字段占用字节多
2. 冗余重复
3. 更换编码

压缩头部算法**HPACK**

* 静态字典 （固定写好的映射表，如2 对应 GET 3 对应POST,8 代表状态码200 )
* 动态字典
* Huffman编码

客户端和服务器两端都会建立和维护「 **字典** 」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，**可达到 50%~90% 的高压缩率**

- [ ] 霍夫曼编码

### 二进制帧

#### 为什么使用二进制

1. 性能。二进制协议的解析效率超高，几乎没有解析代价；
2. 带宽。二进制协议没有冗余字段，占用带宽少；
3. 压缩及Https技术弱化了文本协议的价值；

HTTP/2把相应报文划分成了两类帧(HEADERS)和(DATA)

在HTTP/2中，在[应用层](https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&spm=1001.2101.3001.7020)（HTTP2.0）和传输层（TCP或者UDP）之间加了一层：二进制分帧层。这是HTTP2中最大的改变。HTTP2之所以性能会比HTTP1.1有那么大的提高，很大程度上正是由于这一层的引入。

HTTP2.0通信都在一个连接上完成，这个连接可以承载任意数据量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧**可以乱序发送**，然后再根据每个帧首部的**流标识符**重新组装。HTTP2.0的所有帧都采用二进制编码，所有首部数据都会被压缩。

在HTTP1.1中，如果客户端想发送多个并行的请求，必须使用多个TCP连接，而HTTP2的二进制分帧层突破了这一限制，所有的请求和响应都在同一个TCP连接上完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为可以根据帧首部的流标识符进行重新组装。

- [ ] keep alive是怎么实现的

## 资料

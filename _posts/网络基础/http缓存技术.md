## HTTP缓存有哪些实现方式?

## 什么是强制缓存
利用两个HTTP响应头部字段实现的，都是永安里表示资源在客户端缓存的有效期:
* Cache-Control， 是一个相对时间；
* Expires，是一个绝对时间；
当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
服务器再次收到请求后，会再次更新 Response 头部的 Cache-Contro

在缓存有效期内,浏览器会在设置的时间内直接读取缓存
## 什么是协商缓存
Etag/If-None-Match：
```
Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。
Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
```
If-None-Match:
```
当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304
```
有变化返回200，没变化则304
Last-Modifed/If-Modified-Since的时间精度是秒，而Etag可以更精确。
Etag优先级是高于Last-Modifed的，所以服务器会优先验证Etag
Last-Modifed/If-Modified-Since是http1.0的头字段
### 服务器是怎么标识一个资源的


## HTTP特性
## HTTP1.1 的优点有哪些
## HTTP1.1 的缺点有哪些
## HTTP/1.1的性能如何
HTTP 协议是基于 **TCP/IP**，并且使用了**请求 - 应答**的通信模式，所以性能的关键就在这两点里
1. 长连接
早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。
2. 管道网络传输
HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，如下图：

但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。

如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」，好比上班的路上塞车。

### 性能瓶颈
请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
没有请求优先级控制；
请求只能从客户端开始，服务器只能被动响应。[]

### HTTP/2的优化
1. 压缩头 HPACK
2. 二进制形式
不再是HTTP/1.1的纯文本形式报文，而是全面采用了**二进制格式**
头信息和数据体都是二进制，并且统称为帧:分为头信息帧和数据帧

3. 数据流
* 每个请求或相应的所有数据包，称为一个数据流(Stream)
* 每个数据流都标记着一个独一无二的编号
* 不同Stream的帧可以乱序发送
* 每个帧的都不都会携带Stream ID信息，所以接收端可以通过Stream ID有序组装成HTTP消息
* 双方都可以建立Stream,客户端建立的ID是奇数，服务端建立的ID是偶数
并且还可以指定优先级
4. 多路复用
可以在一个连接汇总并发多个请求或回应，而不用按照顺序一一对应(HTTP1.1通过管道解决了发送端的队头阻塞，没有解决接受端的队头阻塞)，这里是真正解决了。
### 缺陷
#### TCP导致的队头阻塞问题
HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

> TCP的阻塞机制要了解一下，为什么后文说UDP可以阻塞一个流，TCP做不到吗？


5. 服务器推送


## HTTP与HTTPS 有哪些区别
## HTTPS解决了HTTP的哪些问题
## HTTPS是如何建立连接的?其间交互了什么 
## HTTP1.1 HTTP/2 HTTP/3演变
...
---
title: 领域驱动设计·理论篇(一)
category: [领域驱动设计]
tags: [DDD]
layout: post
---

#### DDD 模式体系简介

DDD 是一套方法论，同时也是一套模式体系。DDD 提供了一套从业务到实现的思维过程、实施步骤、团队协作以及持续演进的指导方案。Eric Evans 认为，DDD 是**正确的面向对象（The Right OO）**。OO 不仅指 OOP，而是端到端的面向对象——即以模型为中心的整个开发环节，包括业务需求、架构设计、实现和测试。在 OO 方法中，团队以领域模型为中心进行协作建模，业务、开发和测试使用统一语言描述需求、进行开发和编写自动化测试，架构师依据子域和界限上下文完成系统分治，开发团队采用战术模式完成编码实现。



![img](https://img.imgdb.cn/item/60418ba1360785be54ae5df9.png)





设计领域模型的一般步骤如下：

1.根据需求划分出初步的领域和限界上下文，以及上下文之间的关系；

2.进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象；

3.对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根；

4.为聚合根设计仓储，并思考实体或值对象的创建方式；

5.在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构。



##### 界限上下文

假设有这样一个业务场景：我作为一名咨询师从成都出发前往深圳为客户做领域驱动咨询，无论是从家乘坐地铁到达成都双流机场，还是乘坐飞机到达深圳宝安，再从宝安机场乘坐出租车到达酒店，我的身份都是一名乘客（Passenger），虽然因为交通工具的不同，参与的活动也不尽相同，但无论上车、下车，还是办理登机手续、安检、登机和下机等活动，终归都与交通出行有关。



![img](https://img.imgdb.cn/item/60418a80360785be54adf2fc.png)





根据上面的图发现界限上下文的特点：

●功能相关，各自持有自身所需的知识

●同为一个目标服务，这个角色和自身界限关注点有关

●具有边界

理解界限上下文时，我们需要重视几个关键点：

●知识：不同的界限上下文需要的领域知识是不相同的，这实则就是业务相关性，参与到限界上下文中的活动也与“知识”有关。如果执行该活动却不具备对应知识，则说明对活动的分配不合理；如果该活动的目标与该限界上下文保持一致，却缺乏相应知识，则说明该活动需要与别的界限上下文协作。

●角色：一定要深入思考参与到这个上下文的对象究竟扮演了什么样的角色，以及角色与角色在这个上下文中是如何协作的。

●边界：界限上下文按照不同关注点进行分离，各自的边界则根据耦合关系的强弱来确定，越是关系最弱的地方，越是需要划定边界。

##### 识别界限上下文的方法

一. 划分界限上下文的方法

1.按照语义划分步骤：1.从业务流程中总结出用例（业务场景）如ui自动化有如下业务流程： **登录用户**在一个**创建好的计划**里选择一个空闲或不空闲的设备并**创建任务**，如设备当前不空闲，则**任务排队等待设备**，在排队期间，用户可以手动**取消排队**。当**设备空闲**时，任务**下发到设备**。当任务开始执行后，设备状态从空闲变更为使用中，当任务状态变更后，如从执行中变更为超时、正常结束、有异常或手动取消之后，**发送企业微信通知**。通过对以上业务流程进行分析，结合在各个流程环节中需要的知识以及参与角色的不同，可以划分如下业务场景：1.用户登录2.创建计划3.执行任务4.消息通知业务流程总结业务场景是站在系统层面去划分模块，我只举了系统中的一个业务流程，所以总结出来的方面比较少**业务流程是一个由多个用户角色参与的动态过程，而业务场景则是这些用户角色执行业务活动的静态上下文**5.然后由业务场景总结出业务活动。业务活动由动宾形式描述（不需要主语，不关心主语）拿第一步划分出的**执行任务**举例：1.创建任务2.下发任务然后我拆分不出来了...好像不太对功能相关性相比语义相关性去划分更直接一点，直接抓概念美团技术团队有一篇ddd实践的文章，他们划分上下文就没有用到什么方法，直接抓取需求中的概念划分出界限上下文。如，他们有一个抽奖平台的需求，如下`1. 抽奖活动有活动限制，例如用户的抽奖次数限制，抽奖的开始和结束的时间等；``2. 一个抽奖活动包含多个奖品，可以针对一个或多个用户群体； ``3. 奖品有自身的奖品配置，例如库存量，被抽中的概率等，最多被一个用户抽中的次数等等； ``4. 用户群体有多种区别方式，如按照用户所在城市区分，按照新老客区分等； ``5. 活动具有风控配置，能够限制用户参与抽奖的频率。`提取了一些关键性的概念作为子域，形成了限界上下文。![img](https://img.imgdb.cn/item/6040cf95360785be5468f9e6.png)  然后下面有一行小字:在设计初期，我们曾经考虑划分出抽奖和发奖两个领域，前者负责选奖，后者负责将选中的奖品发放出去。但在实际开发过程中，我们发现这两部分的逻辑紧密连接，难以拆分。并且单纯的发奖逻辑足够简单，仅仅是调用第三方服务进行发奖，不足以独立出来成为一个领域。这行小字让我有点启发，似乎不用太过纠结一开始界限上下文划分的正确性，先大概画一个，发现问题再进行迭代。![img](https://img.imgdb.cn/item/6041a6cf360785be54bdbc5a.png)  第一步到这里完成了，我们进行第二步：**进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象**先放上一张图： ![img](https://img.imgdb.cn/item/6040b4d1360785be545d7eb5.png)   这个图里有如下几个概念：●**聚合根**●**实体**●**领域事件(内部事件)**这三个概念组成了**聚合**聚合是什么，解决了什么问题DDD Reference 中关于聚合的定义将实体和值对象划分为聚合并围绕着聚合定义边界。选择一个实体作为每个聚合的根，并仅允许外部对象持有对聚合根的引用。作为一个整体来定义聚合的属性和不变量，并把其执行责任赋予聚合根或指定的框架机制。 假设有一个企业内部的办公用品采购系统的需求。`1. 企业的员工可以通过该系统提交一个采购请求，一个请求包含了若干数量、若干类型的办公用品（称为采购项）。``2. 主管负责对采购申请进行审批。``3. 审批通过后，系统会根据提供商不同，生成若干订单。`将这个关系进行面向对象建模![img](https://img.imgdb.cn/item/604194c6360785be54b26cd4.png)  面向对象的方式提高了抽象层级，忽略了不必要的技术细节。但是，**业务规则如何保证，在传统的面向对象方法中并没有严格的实现约束**从业务角度来看，如果采购申请的审批已经通过，对采购申请的采购项进行再次更新应该是非法的。但是，在面向对象的世界中，你缺没法阻止程序员写出这样的代码：`    ...``    PurchaseRequest purchaseRequest = getPurchaseRequest(requestId);``    PurchaseItem item = purchaseRequest.getItem(itemId);``    item.setQuantity(1000);``    savePurchaseItem(item);`当然，程序员可以在代码中加入逻辑检查来保证一致性：在修改或保存申请条目前总是检查 purchaseRequest 的状态，如果状态不为草稿就禁止修改。但是，考虑到 PurchaseItem 对象可以在代码的任何位置被取出来，且可能在不同的方法间传递，如果 OO 设计不当，就可能导致该业务逻辑分散到各处。没有**设计约束**，这种检查的实现并不是一件容易的事情。我们在这里总结聚合的一条形式：●聚合是一种**设计约束**，约束开发者无法随意修改数据。但是数据终究是要改的，怎么改呢？让我们回到本质思考：采购项如果脱离采购请求，它自身的单独存在有价值吗？——没有价值。如果没有价值：名义上看起来对采购项的修改，本质上是对采购项的修改吗？还是本质上其实是对采购请求的修改？如果我们认可“修改采购项也是修改采购请求”这个结论，那么我们就不应该分开来研究采购项和采购请求，而是应该如下图所示：![img](https://img.imgdb.cn/item/604196aa360785be54b35da0.png)  外面的这个圈圈标识这个聚合的编辑，我们无法直接跨过边界去访问到采购项，而只能通过暴露在外的“采购请求”去访问、修改数据。我们在这里总结聚合的一条性质:●聚合暴露聚合根作为操作、访问属性的节点**聚合的本质就是建立了一个比对象粒度更大的边界，聚集那些紧密关联的对象，形成了一个业务上的对象整体。使用聚合根作为对外的交互入口，从而保证了多个互相关联的对象的一致性**。合理使用聚合，可以更容易地保证业务规则的一致性，减少了对象之间可能的耦合，提升设计的可理解性，降低出问题的可能性。那么怎么划分聚合呢,比如上面的聚合，采购项分配到了聚合中，那么商品、提交人、审批人要不要划分到聚合中呢？前面说了，聚合是为了保证一致性(目的），所以一致性也能倒退分析出聚合划分的合不合理。一致性是指:●生命周期一致性●问题域一致性●场景一致性生命周期一致性生命周期一致性是指聚合边界内的对象，和聚合根之间存在“人身依附”关系。即：如果聚合根消失，聚合内的其他元素都应该同时消失。例如，在前述例子中，如果聚合根（采购请求）不存在了，那么采购项当然也就失去了存在的意义。而商品、作为申请人的用户等对象，和采购请求之间则不存在此关系。可以用反证法来证明生命周期一致性：如果一个对象在聚合根消失之后仍然有意义，那么说明在系统中必然需要存在其他方法访问该对象。这和聚合的定义相矛盾。所以聚合根内的其他元素必然在聚合根消失后失效。违反生命周期一致性，也会同时带来实现上的严重问题。因此，对于那些说不清楚是否应该划入同一个聚合的对象，**不妨问一下：这个对象如果脱离聚合根，有单独存在的价值吗？**只要答案是否定的，该对象就不属于本聚合问题域一致性问题域就是需求带来的问题空间，而我们上面说的界限上下文其实就是对应的解空间。也就是说，聚合一定要位于同一个界限上下文内。举个例子一个在线论坛，用户可以对论坛上用户的文章发表评论。文章显然应该是一个聚合根。如果文章被删除，那么，用户的评论看起来也要同时消失。那么评论是否可以属于文章这个聚合？目前来说，没有什么问题。但是如果评论还有其他用途，情况就不同了，比如评论还能对论坛上的图书资源发表评论，那么将评论依附于文章的限制就显示出来了：这个依附限制了评论的适用性。所以评论与文章、图书分别位于不同的界限上下文，不能划分为同一个聚合。![img](https://img.imgdb.cn/item/60419c56360785be54b5b30d.png)  场景一致性场景（scenario）是业务用例的具体化描述，反应了用户使用系统达成业务目标的方式。我们可以观察这些场景中涉及的领域对象操作，如对领域对象的查看、修改等。场景操作频率的一致性是同一聚合内部对象的一个关键表征。经常被同时操作的对象，它们属于同一个聚合。而那些极少被同时关注的对象，不应该划为一个聚合。不在同一个场景下操作的对象，放入同一个聚合意味着每次操作一个对象，就需要把其他对象的所有信息抓取到，这是非常没有意义的。从实现层次，如果不紧密相关的对象出现在同一个聚合中，会导致它们经常在不同的场景中被并发修改，也增加了这些对象之间冲突的可能性。所以：大多数时候的操作场景都不一致的对象，或者说如果一个对象在不同场景下都会被使用，应该把它们分到不同的聚合中。 根据上述分析，在采购申请的例子中，采购申请、采购申请的一些属性（如状态、提交时间等）以及采购项属于一个聚合。但是，商品、用户这些不能属于采购申请这个聚合。这些聚合之间如何关联起来呢？我们引入一种新的值对象来解决这个问题，如下图所示。图中也顺便标记了各对象是值对象还是实体对象。![img](https://img.imgdb.cn/item/6041a077360785be54b87044.png)  值对象●存在的意义●聚合不能包含属于其他聚合的实体（因为数据的修改只能由其聚合的根执行），所以引入一个不能修改值的值对象●增强一些缺少描述性的熟悉的描述能力(比如邮箱)●实例化方法●静态工厂●微类型●持久化我们可以使用委派主键的方式，使用两层的层超类型。在上层隐藏委派主键。 这样我们可以自由的将其映射成数据库实体，同时在领域模型中将其建模成值对象。（外键）回到我们最初的ui自动化的问题：![img](https://img.imgdb.cn/item/6040d912360785be546db379.jpg)  首先将设备和任务划分为两个界限上下文，然后识别界限上下文内的实体、值对象，然后为实体和值对象划分范畴，划分为聚合，指定聚合根。然后思考聚合根、值对象的仓储方式。实现方面的考虑实例化和仓库值对象都是依附于聚合根的详情、属性之类，所以单条属性可以作为聚合根对应的表的一个字段，详情可以作为一张单独的表，由聚合根表的主键作为外键。实体是一张单独的表。聚合根是一张单独的表(聚合根就是一个实体)实例化方法：复杂的聚合由工厂方法进行实例，简单的(简单的聚合只有一个实体）由仓储直接提供。为了进一步解耦领域内部聚合可以通过领域事件进行协作。领域事件可以通过事件总线实现(发布/订阅模式)。目录管理1.聚合放到同一个目录下，即一个目录包含聚合根、实体、值对象、仓库 再上一张图展示了ddd的系统架构和协作模式![img](https://img.imgdb.cn/item/6040d28d360785be546a804b.png)  ### 


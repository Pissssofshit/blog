---
title: 使用领域驱动设计进行业务建模
category: [领域驱动设计]
tags: [DDD]
layout: post
---

### 一、技术背景

#### 1.1 什么是领域驱动设计

领域驱动设计(Domain-Driven Design,DDD)是由Eric Evans在其开创性著作《domain driven design tackling complexity in the heart of software》中定义的发展理念。DDD是软件开发的一种方式，它使得团队可以高效管理用于复杂问题域的软件的构造及维护。本篇文章将着重介绍如何使用DDD的理念进行业务建模。

#### 1.2 为什么要业务建模

当今世界上运行和使用的软件，大多是一个个大煤球：一大片随意构造、杂乱无章、凌乱、任意拼接、难以理解的代码丛林，也就是程序猿口中的祖传代码，其中包含着“某种程度上确实有用但无法解释如何运行的代码。“当然这并非大煤球的本来面目：它也曾是一个条理清晰的项目。但是堕落为大煤球似乎是所有项目的宿命。在项目堕落为“大煤球”之后，这个项目将时常引发业务或是开发从灵魂深处发出的怒吼：为什么软件的效果与我的预期不一致？为什么这个简单的需求不能做？为什么一个简单的特性要花这么久？

要揭示这些问题的答案，我们首先要明白混乱与歧义是如何引入项目中的。传统的需求传递模型是这样的

![img](https://airtake-private-data-1254153901.cos.ap-shanghai.myqcloud.com/smart/pontos/1632478999c747f85181f.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDopcCYgw0qRoyV5qfKjvg2pPkqESnb5zI%26q-sign-time%3D1648713338%3B1648716938%26q-key-time%3D1648713338%3B1648716938%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D2bfa34fffc0bcbc961a32d13e80999015bdddd64)

在这条单向的信息链路中，每一个阶段都可能丢失信息:有的业务概念可能被丢失，有的意图可能被曲解，有的活动的重要性可能被忽视，这都可能导致代码设计出现错误或者后续迭代出现问题。这个模型也没有提供检查机制，在代码完成前业务没有办法知道开发方是否有理解偏差，因此业务方只能寄希望于开发方确实正确理解了业务的真实需求。

而在开发人员实现需求的过程中，通常会发现需求与现实不匹配，但是开发人员与业务方没有有效的沟通渠道能将这种知识反馈到分析模型中，于是一些重要的业务概念就丢失了。当代码最终完成的时候，软件可能有业务方想要的功能，但是代码已经不再能反映出业务方的思维模型了。在这种情况下，业务方仍然相信自己的思维模型与真实情况是一致的，而这些分歧会在后续的迭代中逐渐暴露出来。

这就是业务模型要帮助解决的问题：帮助所有软件开发的参与方**对问题的理解保持一致**，**让软件与业务保持一致。** 

### 二、如何使用DDD进行业务建模

DDD的业务建模法通过形成统一语言以消除沟通中的歧义，通过共同构建业务模型保持对软件的认知，通过绑定模型与软件实现使开发过程不会偏离模型，在以上基础上形成知识提炼的循环持续不断地将运营、设计、开发过程中得到的对业务的更深层次的知识提炼到模型中，使项目得到持续迭代并最终达到成功。DDD的建模法大致可以分为四步：



1.建立统一语言

2.基于统一语言进行建模

3.关联模型和代码 

4.精炼模型



#### 2.1 建立统一语言

统一语言是业务双方用于沟通需求、消除歧义后的词汇表。业务双方将使用统一语言描述需求，编写用例，可以帮助挖掘隐含的业务概念，检验现有模型是否能应对需求。在编写用例的过程中统一语言的“词汇表”会不断更新、增长。在用例挑战模型的过程中，业务与开发双方可以看到模型的哪一部分承担了这个用例的功能，能帮助启发双方对模型更深层次的理解也能加深双方对模型的信任。

#### 2.2 基于统一语言进行建模

使用统一语言进行建模，可以屏蔽没有必要的技术细节，使业务也可以在这个环节中参与进来。这使得业务双方都可以对业务建模贡献出自己的知识，以及都能在这个过程中对业务获得更深的见解。这是事实上的一种更深层次的协作关系：因为模型将与代码实现关联，所以开发将失去对代码100%的控制权;同样的，技术也将在这个过程中影响业务。这听上去不可思议，但事实上这样的影响每天都在发生，所不同的是通常开发是暗自用自己的理解替代了业务的想法，而业务浑然不知；而业务也往往会在开发耳朵边催着实现一个开发口中“完全和原先设计违背”的“简单需求”。



#### 2.3 关联模型和代码 

为了防止领域模型与代码实现的割裂，领域模型需要关联代码实现。在面向对象编码风格成为主流的今天，模型与代码相关联已经是一件很寻常的事情。DDD与面向对象相比，它不仅关注业务中的实体，也强调将各类规则、隐含的业务概念进行显示命名，并按照代码分层进行领域对象的编排。这是一个很大的话题了，不在本篇文章的重点讲述内容中。

#### 2.4 精炼模型

当我们拥有了一份统一语言，一个看上去还不赖的业务模型，这个时候我们就需要用更多的用例去挑战我们现有的业务模型了。在这个过程中，我们将更新先前发掘的业务概念，添加新的元素，改变模型的结构。然后就可以开始编码了，注意在编码过程中发现的新的业务概念要及时反映到模型和统一语言中，否则业务模型就会在分歧中渐渐失效。



### 三、DDD业务建模小结

DDD的业务建模是一种迭代式法，它强调构建一个有效的知识循环，并将模型置于整个循环的中心位置确保模型在迭代中不会失效。这是DDD的业务建模模型



![img](https://airtake-private-data-1254153901.cos.ap-shanghai.myqcloud.com/smart/pontos/16324790370555ef59b2c.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDopcCYgw0qRoyV5qfKjvg2pPkqESnb5zI%26q-sign-time%3D1648713338%3B1648716938%26q-key-time%3D1648713338%3B1648716938%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D25927a1430840a1e0fc53f5319db85c4216b9c6a)







可以看到在这个模型中，统一语言往左是歧义最大的原始需求，往右则是定义准确的模型代码，统一语言在此扮演的是一个隔离原始需求歧义的中间层，它向左隔离歧义，向右启发模型。

![img](https://airtake-private-data-1254153901.cos.ap-shanghai.myqcloud.com/smart/pontos/16324790452920c0cff3c.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDopcCYgw0qRoyV5qfKjvg2pPkqESnb5zI%26q-sign-time%3D1648713338%3B1648716938%26q-key-time%3D1648713338%3B1648716938%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D3443daa05e8e54ec9b849a276b2dfb73def98fad)

### 四、技术实现

#### 4.1 项目目标

我们在Q2、Q3的主要目标是搭建mPaas(**M**obile **P**latform **A**s **A** **S**ervice)平台,目标成为应用搭建的基础设施，提供App全生命周期全方位的服务支撑。

#### 4.2 初次建模

mPaas的核心需求之一是

> **作为一个应用负责人，我希望掌握一个应用开发全阶段数据，以便掌握应用的全面情况**

一个应用的开发阶段的数据在CI平台，上线后的奔溃信息在Crash平台，mPaas起到的就是串通平台底层数据的作用

于是我们定义

> **应用：mPaas中的基础元素,以包名+平台作为唯一标识**

这样设计的意图是：在现实世界，在一台手机上不能存在两个相同包名的应用，也就是说包名加上平台是一个现实世界中“应用”的最小粒度，因此mPaas平台可以以此去联系其他子平台中存在的应用数据。各个子系统中都有自己的“应用”概念，比如在CI平台中每个项目都与包名相关联，因此可以用mPaas的应用去串联；在Crash平台中，“应用“的概念则与ng平台中的”应用“概念对齐，因此需要在mPaas的应用概念之上做聚合。

> ng平台中的应用会包含多个包名

针对Crash平台的情况，定义以下概念

> **聚合：一个包含多个应用的集合，根据不同的维度聚合应用数据**

具体的讲，就是将mPaas中的应用按照ng的规则将一些应用作为一个聚合，这个聚合就作为Crash平台的入口。

根据这样的定义得到mPaas的业务模型

![img](https://airtake-private-data-1254153901.cos.ap-shanghai.myqcloud.com/smart/pontos/1632479080e4587100620.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDopcCYgw0qRoyV5qfKjvg2pPkqESnb5zI%26q-sign-time%3D1648713338%3B1648716938%26q-key-time%3D1648713338%3B1648716938%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D637f86367be86eaaa35fa639af06175e9ec4ae54)

>  虚线表示与之关联的外部系统

然后使用用户故事检验得到的业务模型：

> **作为一个开发者，我想要在mPaas平台上找到对应的入口，以便对特定的应用进行打包**
>
> **作为一个开发者，我想要在mPaas平台上找到对应的入口，以查看应用的最新的crash数据**

经过检验当前模型可以满足现有用例：两个子平台都可以找到对应的应用/聚合作为入口进入。

#### 4.5 模型精炼

可是这个模型在实际的使用中并不尽如人意，用户很难弄明白为什么使用CI平台需要从应用进，而使用Crash平台需要从聚合进。从用户的角度来看，我要看的数据都是属于”应用“的，而你们的“聚合”是什么鬼？由此我们发现，各个子平台中的应用概念是与ng应用概念对齐的。因此mPaas平台中的“应用”不应该采取现实世界“应用”的定义，所以应用的定义更新为

> **应用：mpaas中的基础元素，以ng平台的应用ID+平台作为唯一标识, 与ng平台中的应用对齐**

在后续的讨论中，我们从需求中得到了更多的用例

> **作为公版开发者，我希望能看到公版的所有数据，以便能掌握公版应用的全局情况**
>
> **作为商照开发者，我希望能看到商照的所有数据，以便能掌握商照应用的全局情况**
>
> **作为RN开发者,我希望面板能作为一个整体，以便能看到这个面板的跨应用数据**
>
> **作为模块开发者，我希望模块能作为一个整体，以便能看到这个模块的跨应用数据**

从这些用例中我们发掘出了更多的基本元素：应用、模块、面板，而在这些基本元素之上，它们还隐含着更高层次的抽象，比如应用可以按照业务线分为公版、照明，模块、面板又可以按照业务模块分类为配网、蓝牙。于是我们更新聚合的定义

> **聚合:一个包含多个基本元素的集合，隐含着业务线/业务模块的概念**

同时更新我们的业务模型

![img](https://airtake-private-data-1254153901.cos.ap-shanghai.myqcloud.com/smart/pontos/16324791021d3f49f1e9b.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDopcCYgw0qRoyV5qfKjvg2pPkqESnb5zI%26q-sign-time%3D1648713338%3B1648716938%26q-key-time%3D1648713338%3B1648716938%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D2be1a200d8efa1ffedb9e82140cce92acbadb571)







### 五、总结感悟

业务建模首先是一个定义问题的方法，其次才是解决问题的方法。在日常工作中，无论是业务或是开发常常会带着解决方案来描述一个问题，但是对问题的本身的探讨却被忽略了。DDD业务建模让人们回到关注问题本身，明确业务中的关键问题，使用精炼的模型表达，确实是一种优秀的理念。